(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



BeginPackage["DiFfRG`CodeTools`"];
Unprotect["DiFfRG`CodeTools`*"];
ClearAll["DiFfRG`CodeTools`*"];
ClearAll["DiFfRG`CodeTools`Private`*"];


FlowKernel::usage = "FlowKernel[expr_,name_String,NT_String:\"auto\",addprefix_String:\"\"]
Makes an equation into a lambda expression - of limited usefulness, but can be used together with LoopIntegrals::integrate and similar functions.";

ExportCode::usage = "ExportCode[fileName_String,expression_String]
Writes the given expression to disk and runs clang-format on it.
";

CodeForm::usage = "CodeForm[expr_]
Obtain properly formatted and processed C++ code from an expression.";

SetCppNames::usage = "SetCppNames[rules___]
Set additional replacement rules used when invoking CodeForm[expr].

Example Call: SetCppNames[\"k\"->\"k_bosonic\", \"Arccos(\"->\"std::arccos(\"]";

JuliaForm::usage = "CodeForm[expr_]
Obtain properly formatted and processed Julia code from an expression.";

UnicodeClip::usage = "UnicodeClip[expr_String]
Copy a string as unicode into the clipboard. Useful when exporting to Julia.";

MakeCMakeFile::usage = "MakeCMakeFile[kernels_List]
Creates a CMakeLists.txt inside the 'flowDir' which you can set using SetFlowDir[dir_String]. This CMake file contains references to all kernels specified in the List 'kernels'. Make sure you have created all kernels before compiling!
If so, simply add the flow directory in the parent directory of the flow directory: \n add_subdirectory(flows) \n Note that this CMakeLists.txt exports its source files into parent scope as $flow_sources
Thus, to compile the flows, simply add them as source files:
    add_executable(QCD QCD.cc ${flow_sources})";


SetFlowDirectory::usage="SetFlowDirectory[dir]
Set the current flow directory, i.e. where all generated files are saved. Default is ./flows/";
ShowFlowDirectory::usage="ShowFlowDirectory[]
Show the current flow directory, i.e. where all generated files are saved. Default is ./flows/";

MakeFlowClass::usage = "MakeFlowClass[name_String,kernels_List]
This creates a file flows.hh inside the flow directory, containing a class with the specified name, as well as several other files. All defined kernels have a corresponding integrator object in this class.
Automatically calls MakeCMakeFile with the passed list of kernels.";

MakeFlowClassFiniteT::usage = "MakeFlowClassFiniteT[name_String,kernels_List]
This creates a file flows.hh inside the flow directory, containing a class with the specified name, as well as several other files. All defined kernels have a corresponding integrator object in this class.
Automatically calls MakeCMakeFile wiht the passed list of kernels.";

MakeKernel::usage = "MakeKernel[kernel_Association, parameterList_List,integrandFlow_,constantFlow_:0., integrandDefinitions_String:\"\", constantDefinitions_String:\"\"]
Make a kernel from a given flow equation, parmeter list and kernel. The kernel must be a valid specification of an integration kernel.
This Function creates an integrator that evaluates (constantFlow + \[Integral]integrandFlow). One can prepend additional c++ definitions to the flow equation by using the integrandDefinitions and constantDefinitions parameters. 
These are prepended to the respective methods of the integration kernel, allowing one to e.g. define specific angles one needs for the flow code.";

DeclareSymmetricPoints4DP4::usage="DeclareSymmetricPoints4DP4[]
Obtain C++ code declaring angles for a four-point symmetric configuration in 4D.
The angles will have the names cosp1q, cosp2q, cosp3q and cosp4q.
DeclareSymmetricPoints4DP4[computeType]
Set the type of the declared C++ variables (should be double or float).";

DeclareSymmetricPoints4DP3::usage="DeclareSymmetricPoints4DP3[]
Obtain C++ code declaring angles for a four-point symmetric configuration in 4D.
The angles will have the names cosp1q, cosp2q, cosp3q and cosp4q.
DeclareSymmetricPoints4DP3[computeType]
Set the type of the declared C++ variables (should be double or float).";

DeclareSymmetricPoints3DP4::usage="DeclareSymmetricPoints3DP4[]
Obtain C++ code declaring angles for a four-point symmetric configuration in 3D.
The angles will have the names cosp1q, cosp2q, cosp3q and cosp4q.
DeclareSymmetricPoints3DP4[computeType]
Set the type of the declared C++ variables (should be double or float).";

DeclareSymmetricPoints3DP3::usage="DeclareSymmetricPoints3DP3[]
Obtain C++ code declaring angles for a three-point symmetric configuration in 3D.
The angles will have the names cosp1q, cosp2q and cosp3q.
DeclareSymmetricPoints3DP3[computeType]
Set the type of the declared C++ variables (should be double or float).";

DeclareSymmetricPoints2DP4::usage="DeclareSymmetricPoints2DP4[]
Obtain C++ code declaring angles for a four-point symmetric configuration in 2D.
The angles will have the names cosp1q, cosp2q, cosp3q and cosp4q.
DeclareSymmetricPoints2DP4[computeType]
Set the type of the declared C++ variables (should be double or float).";

DeclareSymmetricPoints2DP3::usage="DeclareSymmetricPoints2DP3[]
Obtain C++ code declaring angles for a three-point symmetric configuration in 2D.
The angles will have the names cosp1q, cosp2q and cosp3q.
DeclareSymmetricPoints2DP3[computeType]
Set the type of the declared C++ variables (should be double or float).";

DeclareAnglesP34Dpqr::usage="DeclareAnglesP34Dpqr[q,p,r]
Obtain C++ code declaring angles for the angles in a full three-point function in 4D.
The angles will have the names cospq and cosqr, where q,p,r are replaced by the given Symbol names and ordered alphabetically.
DeclareAnglesP34Dpqr[q,p,r,computeType]
Set the type of the declared C++ variables (should be double or float).";

SafeFiniteTFunctions::usage="";

ShowTypes::usage="ShowTypes[]
Show a list of all types available for use in a parameter list to make a kernel.";

AddCodeOptimizeFunctions::usage="AddCodeOptimizeFunctions[func1[__], func2[__],...]
Add the functions func1, func2, ... to the functions to be optimized out, i.e. calculated only once in auto-generated kernel code.";

ShowCodeOptimizeFunctions::usage="ShowCodeOptimizeFunctions[]
Show a list of all functions which DiFfRG will try to optimize out when generating C++ code.";

ClearCodeOptimizeFunctions::usage="ClearCodeOptimizeFunctions[]
Remove all optimization functions from the internal list";

UseKernelOptimizations::usage="UseKernelOptimizations[True]
Turn on code optimizations in auto-generation of C++ code.
UseKernelOptimizations[False]
Turn off code optimizations in auto-generation of C++ code.
";

SetKernelDefinitions::usage="SetKernelDefinitions[definitionCode_String] sets the kernel definitions to definitionCode.
SetKernelDefinitions[] resets the kernel definitions to the standard.";

ShowKernelDefinitions::usage="ShowKernelDefinitions[]
Show the currently specified kernel definitions code.";

AddParameterType::usage="AddParameterType[name,cppType,cppTypeAD,Reference,computeTypeName]
Add a recognized parameter to the list of useable kernel parameter types.
";

SetCodeParser::usage="";


Begin["`Private`"];


Needs["SymbolicC`"]
CodeFormatted[expr_,computeType_String:"double"] :=Module[{Powergen,Powery,Sqrty,RemoveFormat,res},
	Format[Powergen[a_,b_],CForm]:="pow("~~ToString[a,CForm]~~", "~~ToString[b,CForm]~~")";
	Format[Powery[a_,b_],CForm]:="powr<"~~ToString[b,CForm]~~">("~~ToString[a,CForm]~~")";
	Format[Sqrty[a_],CForm]:="sqrt("~~ToString[a,CForm]~~")";

	RemoveFormat[exp_]:=Module[{ret},
		ret=exp;
		ret=StringReplace[ret,{"Max(":>"max("}];
		ret=StringReplace[ret,{"Min(":>"min("}];
		ret=StringReplace[ret,{"Re(":>"real("}];
		ret=StringReplace[ret,{"Im(":>"imag("}];
		ret=StringReplace[ret,{"Sqrt(":>"sqrt("}];
		ret=StringReplace[ret,{"Log(":>"log("}];
		ret=StringReplace[ret,{"Abs(":>"abs("}];
		ret=StringReplace[ret,{"Complex(":>"complex<"<>computeType<>">("}];
		ret=StringReplace[ret,{"powr<1>(":>"("}];
		ret=StringReplace[ret,{"HeavisideTheta(":>"heaviside_theta("}];
		While[StringCount[ret,{"\\","\""," "}]>0,
			ret=StringReplace[ret,{"\\"->"","\""->""," "->""}]
		];
		ret
	];

	res=ToCCodeString[
		CExpression[
			expr//.{Power[a_,b_Integer]->Powery[a,b], Power[a_,b_/;Element[b+1/2,Integers]]->Powery[Sqrty[a],2b],Power[a_,b_]->Powergen[a,b]}//.ArcTan[a_,b_]:>Global`atan2[a,b]
		]
	]//RemoveFormat;
	
	If[computeType=="float",
	res=StringReplace[res,a:DigitCharacter..~~"."~~b:DigitCharacter..~~"e-"~~c:DigitCharacter..:>a~~"."~~b~~"*"~~ToString[DecimalForm[10^-ToExpression[c]//N]]];
	res=StringReplace[res,a:DigitCharacter..~~"."~~"e-"~~c:DigitCharacter..:>a~~"."~~"*"~~ToString[DecimalForm[10^-ToExpression[c]//N]]];
	res=StringReplace[res,a:DigitCharacter..~~"."~~b:DigitCharacter..:>a~~"."~~b~~"f"];
	res=StringReplace[res,a:DigitCharacter..~~"."~~b:Except[DigitCharacter]:>a~~".f"~~b];
	res=StringReplace[res,a:DigitCharacter..~~"."~~EndOfString:>a~~".f"];
	];
	res=StringReplace[res,{"Complex(":>"complex<"<>computeType<>">("}];
	Return[res//RemoveFormat];
];

CppNames={};
SetCppNames[rules___]:=Module[{baseList,ruleList},
	baseList={
		"Sin("->"sin(",
		"Cos("->"cos(",
		"Tan("->"tan(",
		"Cot("->"cot(",
		"q0f"->"(q0 + M_PI * T)"
	};
	ruleList={rules};
	CppNames=Join[ruleList,baseList];
];

SetCppNames[]

CodeForm[expr_,computeType_String:"double"]:=StringDelete[StringReplace[CodeFormatted[N[expr],computeType],CppNames],"\n"|"\r"];
   
SafeFiniteTFunctions[expr_,T_]:=Module[{a},
expr//.{
Tanh[a_/(2 T)]:>Symbol["TanhFiniteT"][a,T],Tanh[a_/T]:>Symbol["TanhFiniteT"][a,2T],Tanh[a_/(2 T)]^n_:>Symbol["TanhFiniteT"][a,T]^n,Tanh[a_/T]^n_:>Symbol["TanhFiniteT"][a,2T]^n,
Coth[a_/(2 T)]:>Symbol["CothFiniteT"][a,T],Coth[a_/T]:>Symbol["CothFiniteT"][a,2T],Coth[a_/(2 T)]^n_:>Symbol["CothFiniteT"][a,T]^n,Coth[a_/T]^n_:>Symbol["CothFiniteT"][a,2T]^n,
Csch[a_/(2 T)]:>Symbol["CschFiniteT"][a,T],Csch[a_/T]:>Symbol["CschFiniteT"][a,2T],Csch[a_/(2 T)]^n_:>Symbol["CschFiniteT"][a,T]^n,Csch[a_/T]^n_:>Symbol["CschFiniteT"][a,2T]^n,
Sech[a_/(2 T)]:>Symbol["SechFiniteT"][a,T],Sech[a_/T]:>Symbol["SechFiniteT"][a,2T],Sech[a_/(2 T)]^n_:>Symbol["SechFiniteT"][a,T]^n,Sech[a_/T]^n_:>Symbol["SechFiniteT"][a,2T]^n
}
]

clangFormatExists=Quiet[RunProcess[{"clang-format","--help"}]]=!=$Failed;
CreateClangFormat[]:=If[Not@FileExistsQ[".clang-format"],
Export[".clang-format",
"BasedOnStyle: LLVM
UseTab: Never
IndentWidth: 2
TabWidth: 2
BreakBeforeBraces: Linux
AllowShortIfStatementsOnASingleLine: true
IndentCaseLabels: false
ColumnLimit: 120
AccessModifierOffset: -2
NamespaceIndentation: All
AllowShortEnumsOnASingleLine: true
",
"Text"]
];

ExportCode[fileName_String,expression_String]:=Module[{tmpfileName},
	tmpfileName=fileName<>".tmpcode";
	Export[tmpfileName,expression,"Text"];
	If[clangFormatExists,
		CreateClangFormat[];
		RunProcess[$SystemShell, All, "clang-format "<>tmpfileName<>" > "<>tmpfileName<>"_formatted && mv "<>tmpfileName<>"_formatted "<>tmpfileName];
	];
	If[FileExistsQ[fileName],
		If[Import[fileName,"Text"]==Import[tmpfileName,"Text"],
			Print[fileName<>" unchanged"];
			RunProcess[$SystemShell, All, "rm "<>tmpfileName],
			Print["Exported to "<>fileName];
			RunProcess[$SystemShell, All, "mv "<>tmpfileName<>" "<>fileName]
		],
		Print["Exported to "<>fileName];
		RunProcess[$SystemShell, All, "mv "<>tmpfileName<>" "<>fileName]
	]
]


FlowKernel[expr_,name_String,NT_String:"auto",addprefix_String:""]:=Module[{head,prefix,integrand},
	head="auto "~~name~~"_kernel = [=, this](const double q2) -> "~~NT~~" {\n";
	If[MemberQ[expr,Symbol["q0"],-1]||MemberQ[expr,Symbol["q0f"],-1],head="auto "~~name~~"_kernel = [=, this](const double q2, const double q0) -> "~~NT~~" {\n";];If[MemberQ[expr,Symbol["cos"],-1],head="auto "~~name~~"_kernel = [=, this](const double q2, const double cos) -> "~~NT~~" {\n";];If[MemberQ[expr,Symbol["cos"],-1]&&(MemberQ[expr,Symbol["q0"],-1]||MemberQ[expr,Symbol["q0f"],-1]),head="auto "~~name~~"_kernel = [=, this](const double q2, const double cos, const double q0) -> "~~NT~~" {\n";];

	prefix="";
	If[MemberQ[expr,Symbol["q"],-1],prefix=prefix~~"  const double q = sqrt(q2);\n"];If[MemberQ[expr,Symbol["q0f"],-1],prefix=prefix~~"  const double q0f = q0 + M_PI * prm.T;\n"];If[MemberQ[expr,Symbol["RB"][Symbol["k"]^2,Symbol["q"]^2],-1],prefix=prefix~~"  const double RB = RB(powr<2>(k), q2);\n"];If[MemberQ[expr,Symbol["RBdot"][Symbol["k"]^2,Symbol["q"]^2],-1],prefix=prefix~~"  const double RBdot = RBdot(powr<2>(k), q2);\n"];If[MemberQ[expr,Symbol["RF"][Symbol["k"]^2,Symbol["q"]^2],-1],prefix=prefix~~"  const double RF = RF(powr<2>(k), q2);\n"];If[MemberQ[expr,Symbol["RFdot"][Symbol["k"]^2,Symbol["q"]^2],-1],prefix=prefix~~"  const double RFdot = RFdot(powr<2>(k), q2);\n"];
prefix=prefix~~addprefix;
If[prefix!="",prefix=prefix~~"\n"];

integrand="  return real("~~CodeForm[expr]~~");\n";

head~~prefix~~integrand~~"};"
]


(* ::Input::Initialization:: *)
ArgType=<|
"Constant"->"",
"Variable"->"",
"ComplexConstant"->"",
"ComplexVariable"->"",
"FunctionTex1D"->"&",
"FunctionTex2D"->"&",
"FunctionTex3D"->"&",
"FunctionTex3DLogLinLin"->"&",
"Function1D"->"&",
"Function2D"->"&",
"Function2DLinLin"->"&",
"Function3D"->"&",
"Function3DLogLinLin"->"&",
"FunctionTex1DBosonicFT"->"&",
"FunctionTex1DFermionicFT"->"&"
|>;
$CppType=<|
"Constant"->"$computeType",
"Variable"->"$computeType",
"ComplexConstant"->"complex<$computeType>",
"ComplexVariable"->"complex<$computeType>",

"FunctionTex1D"->"TexLinearInterpolator1D<double, LogarithmicCoordinates1D<float>>",

"FunctionTex2D"->"TexLinearInterpolator2D<double, CoordinatePackND<LogarithmicCoordinates1D<float>, LogarithmicCoordinates1D<float>>>",
"FunctionTex2DLinLin"->"TexLinearInterpolator2D<double, CoordinatePackND<LinearCoordinates1D<float>, LinearCoordinates1D<float>>>",

"FunctionTex3D"->"TexLinearInterpolator3D<double, CoordinatePackND<LogarithmicCoordinates1D<float>, LogarithmicCoordinates1D<float>, LinearCoordinates1D<float>>>",
"FunctionTex3DLogLinLin"->"TexLinearInterpolator3D<double, CoordinatePackND<LogarithmicCoordinates1D<float>, LinearCoordinates1D<float>, LinearCoordinates1D<float>>>",

"Function1D"->"LinearInterpolator1D<double, LogarithmicCoordinates1D<float>>",

"Function2D"->"LinearInterpolator2D<double, CoordinatePackND<LogarithmicCoordinates1D<float>, LogarithmicCoordinates1D<float>>>",
"Function2DLinLin"->"LinearInterpolator2D<double, CoordinatePackND<LinearCoordinates1D<float>, LinearCoordinates1D<float>>>",

"Function3D"->"LinearInterpolator3D<double, CoordinatePackND<LogarithmicCoordinates1D<float>, LogarithmicCoordinates1D<float>, LinearCoordinates1D<float>>>",
"Function3DLogLinLin"->"LinearInterpolator3D<double, CoordinatePackND<LogarithmicCoordinates1D<float>, LinearCoordinates1D<float>, LinearCoordinates1D<float>>>",

"FunctionTex1DBosonicFT"->"TexLinearInterpolator1DStack<double, BosonicCoordinates1DFiniteT<int, float>>",
"FunctionTex1DFermionicFT"->"TexLinearInterpolator1DStack<double, FermionicCoordinates1DFiniteT<int, float>>"
|>;
CppType[computeType_String]:=Map[StringReplace[#,"$computeType"->computeType]&,$CppType]
$CppTypeAD=<|
"Constant"->"$computeType",
"Variable"->"autodiff::real",
"ComplexConstant"->"complex<$computeType>",
"ComplexVariable"->"complex<autodiff::real>",

"FunctionTex1D"->"TexLinearInterpolator1D<autodiff::real, LogarithmicCoordinates1D<float>>",

"FunctionTex2D"->"TexLinearInterpolator2D<autodiff::real, CoordinatePackND<LogarithmicCoordinates1D<float>, LogarithmicCoordinates1D<float>>>",
"FunctionTex2DLinLin"->"TexLinearInterpolator2D<autodiff::real, CoordinatePackND<LinearCoordinates1D<float>, LinearCoordinates1D<float>>>",

"FunctionTex3D"->"TexLinearInterpolator3D<autodiff::real, CoordinatePackND<LogarithmicCoordinates1D<float>, LogarithmicCoordinates1D<float>, LinearCoordinates1D<float>>>",
"FunctionTex3DLogLinLin"->"TexLinearInterpolator3D<autodiff::real, CoordinatePackND<LogarithmicCoordinates1D<float>, LinearCoordinates1D<float>, LinearCoordinates1D<float>>>",

"Function1D"->"LinearInterpolator1D<autodiff::real, LogarithmicCoordinates1D<float>>",

"Function2D"->"LinearInterpolator2D<autodiff::real, CoordinatePackND<LogarithmicCoordinates1D<float>, LogarithmicCoordinates1D<float>>>",
"Function2DLinLin"->"LinearInterpolator2D<autodiff::real, CoordinatePackND<LinearCoordinates1D<float>, LinearCoordinates1D<float>>>",

"Function3D"->"LinearInterpolator3D<autodiff::real, CoordinatePackND<LogarithmicCoordinates1D<float>, LogarithmicCoordinates1D<float>, LinearCoordinates1D<float>>>",
"Function3DLogLinLin"->"LinearInterpolator3D<autodiff::real, CoordinatePackND<LogarithmicCoordinates1D<float>, LinearCoordinates1D<float>, LinearCoordinates1D<float>>>",

"FunctionTex1DBosonicFT"->"TexLinearInterpolator1DStack<autodiff::real, BosonicCoordinates1DFiniteT<int, float>>&",
"FunctionTex1DFermionicFT"->"TexLinearInterpolator1DStack<autodiff::real, FermionicCoordinates1DFiniteT<int, float>>&"
|>;
CppTypeAD[computeType_String]:=Map[StringReplace[#,"$computeType"->computeType]&,$CppTypeAD]

AddParameterType[name_String,cppType_String,cppTypeAD_String,Reference_:True,computeTypeName_String:"$computeType"]:=Module[{},
If[MemberQ[Keys[ArgType],name]||MemberQ[Keys[$CppType],name]||MemberQ[Keys[$CppTypeAD],name],
Print["Parameter type with name \""<>name<>"\" already exists!"];Abort[]];

If[Reference,
AppendTo[ArgType,name->"&"],
AppendTo[ArgType,name->""]
];

AppendTo[$CppType,name->cppType];
AppendTo[$CppTypeAD,name->cppTypeAD];
];

ShowTypes[]:=Module[{},
Print["Available argument types (for double) are: ",Dataset[Association[Map[{#->{$CppType[#],$CppTypeAD[#]}}&,Keys[$CppType]]],MaxItems->20000]];
]


GridSelector[kernel_]:=Module[{},
Return@If[kernel["Type"]=="CartesianQuadrature",
Switch[kernel["d"],
1,"grid_size_int",
2,"grid_sizes_2D_cartesian_int",
3,"grid_sizes_3D_cartesian_int",
_,Print["CartesianQuadrature has wrong dimension!"];Abort[];
],
Switch[kernel["Angles"],
0,"grid_size_int",
1,"grid_sizes_angle_int",
2,"grid_sizes_3D_int",
3,"grid_sizes_4D_int"
]
];
];

GridSelectorFiniteT=<|
0->"grid_sizes_int_fT",
1->"grid_sizes_angle_int_fT",
2->"grid_sizes_4D_int_fT"
|>;

DeviceChoice["CPU"]="TBB";
DeviceChoice["TBB"]="TBB";
DeviceChoice["GPU"]="GPU";


(* ::Input::Initialization:: *)
flowDir=If[$Notebooks,NotebookDirectory[],Directory[]]<>"flows/";
SetFlowDirectory[dir_String]:=Module[{},flowDir=dir]
ShowFlowDirectory[]:=Print[flowDir]

Print["Flow output directory: "<>flowDir]


(* ::Input::Initialization:: *)
MakeCMakeFile[kernels_List]:=Module[{cuKernelList,ccKernelList,CMakeListsTxt,fileName=flowDir<>"CMakeLists.txt"},
If[Not@IsValidKernelSpecList[kernels],Print["Invalid kernels list!"];Abort[]];

cuKernelList=StringDrop[StringJoin[Map["    flows/"<>#["Path"]<>"/"<>#["Name"]<>".cu\n"&,kernels]],-1];
ccKernelList=StringDrop[StringJoin[Map["    flows/"<>#["Path"]<>"/"<>#["Name"]<>".cc\n"&,kernels]],-1];
CMakeListsTxt="if(USE_CUDA)
  set(flow_sources
"<>cuKernelList<>"
	flows/flows.cc
    PARENT_SCOPE)
else()
  set(flow_sources
"<>ccKernelList<>"
	flows/flows.cc
    PARENT_SCOPE)
endif()";

If[FileExistsQ[fileName],
If[Import[fileName,"Text"]==CMakeListsTxt,
Print[fileName<>" unchanged"];
Return[]
];
	];
Export[fileName,CMakeListsTxt,"Text"];
Print["Exported to \""<>fileName<>"\""];
];


CheckKey[kernel_Association,name_String,test_]:=Module[{valid},
If[Not@KeyExistsQ[kernel,name],Print["Missing kernel key: ",name];Return[False]];
If[Not@test[kernel[name]],Return[False]];
Return[True];
];


knownTypes={"Quadrature","QMC","Quadrature","Quadratureq0","Quadraturex0","CartesianQuadrature","CartesianQuadratureq0"};
TypeTest[type_]:=Module[{},
If[MemberQ[knownTypes,type],Return[True],Print["Unkown kernel Type: ",type, "\nKnown types: ",knownTypes];Return[False]]
];
AngleTest[number_]:=Module[{},
If[0<=number<=3,Return[True],Print["Invalid number of Angles: ",number,"\nMust be between 0 and 3."];Return[False]]
];
knownctypes={"double","float"};
ctypeTest[type_]:=Module[{},
If[MemberQ[knownctypes,type],Return[True],Print["Unkown kernel ctype: ",type, "\nKnown ctypes: ",knownctypes];Return[False]]
];
knownDevices={"CPU","TBB","GPU"};
deviceTest[type_]:=Module[{},
If[MemberQ[knownDevices,type],Return[True],Print["Unkown kernel Device: ",type, "\nKnown Devices (where TBB=CPU): ",knownDevices];Return[False]]
];


(* ::Input::Initialization:: *)
IsValidKernelSpec[kernel_Association]:=Module[{validKeys,validKeyTypes},
validKeys=CheckKey[kernel,"Path"]&&
CheckKey[kernel,"Name",StringQ]&&
CheckKey[kernel,"Type",TypeTest]&&
CheckKey[kernel,"Angles",AngleTest]&&
CheckKey[kernel,"d",IntegerQ]&&
CheckKey[kernel,"AD",BooleanQ]&&
CheckKey[kernel,"ctype",ctypeTest]&&
CheckKey[kernel,"Device",deviceTest];
Return[validKeys];
];

IsValidKernelSpecList[kernels_List]:=Module[{validList,validSpecs},
validList=AllTrue[kernels,AssociationQ];
validSpecs=AllTrue[kernels,IsValidKernelSpec];

validList&&validSpecs
]


knownParamTypes=Keys[ArgType];
TestParamType[type_]:=Module[{},
If[MemberQ[knownParamTypes,type],Return[True],Print["Unkown kernel ctype: ",type, "\nKnown ctypes: ",knownParamTypes];Return[False]]
];


(* ::Input::Initialization:: *)
IsValidParameter[parameter_Association]:=Module[{validKeys,validKeyTypes},
validKeys=
KeyExistsQ[parameter,"Name"]&&
KeyExistsQ[parameter,"Type"]&&
KeyExistsQ[parameter,"AD"];

validKeyTypes=
StringQ[parameter["Name"]]&&
TestParamType[parameter["Type"]]&&
BooleanQ[parameter["AD"]];

validKeys&&validKeyTypes
];

IsValidParameterList[parameters_List]:=Module[{validList,validParams},
validList=AllTrue[parameters,AssociationQ];
validParams=AllTrue[parameters,IsValidParameter];

validList&&validParams
]


DeclareAnglesP34Dpqr[q_,p_,r_,computeType_String:"double"]:=Module[
{vec4,Vectorp,Vectorr,Vectorq,cos,
Resultcospq,Resultcosqr,namecospq,namecosqr,
code,file},

vec4[\[CapitalTheta]1_,\[CapitalTheta]2_,\[Phi]_]:={Cos[\[CapitalTheta]1],Sin[\[CapitalTheta]1]Cos[\[CapitalTheta]2],Sin[\[CapitalTheta]1]Sin[\[CapitalTheta]2]Cos[\[Phi]],Sin[\[CapitalTheta]1]Sin[\[CapitalTheta]2]Sin[\[Phi]]};
SetAttributes[cos,Orderless];

Vectorp=vec4[0,0,0];
Vectorr=vec4[ArcCos[cos[p,r]],0,0];
Vectorq=vec4[ArcCos[Symbol["cos1"]],ArcCos[Symbol["cos2"]],Symbol["phi"]];

Resultcospq=Vectorq . Vectorp//.cos[a_,b_]:>Symbol["cos"<>ToString[a]<>ToString[b]]//FullSimplify;
Resultcosqr=Vectorq . Vectorr//.cos[a_,b_]:>Symbol["cos"<>ToString[a]<>ToString[b]]//FullSimplify;

namecospq=cos[p,q]//.cos[a_,b_]:>Symbol["cos"<>ToString[a]<>ToString[b]];
namecosqr=cos[q,r]//.cos[a_,b_]:>Symbol["cos"<>ToString[a]<>ToString[b]];

code="const "<>computeType<>" "<>ToString[namecospq]<>" = "<>CodeForm[Resultcospq,computeType]<>";\n"<>
"const "<>computeType<>" "<>ToString[namecosqr]<>" = "<>CodeForm[Resultcosqr,computeType]<>";";
Return[code];
];


(* ::Input::Initialization:: *)
DeclareSymmetricPoints4DP4[computeType_String:"double"]:=Module[
{vec4,sanity,Vectors4DSP4,
SymmetricPoint4DP4cosp1,SymmetricPoint4DP4cosp2,SymmetricPoint4DP4cosp3,SymmetricPoint4DP4cosp4,SymmetricPoint4DP4Code
},

vec4[\[CapitalTheta]1_,\[CapitalTheta]2_,\[Phi]_]:={Cos[\[CapitalTheta]1],Sin[\[CapitalTheta]1]Cos[\[CapitalTheta]2],Sin[\[CapitalTheta]1]Sin[\[CapitalTheta]2]Cos[\[Phi]],Sin[\[CapitalTheta]1]Sin[\[CapitalTheta]2]Sin[\[Phi]]};

Vectors4DSP4={vec4[\[Pi]/2,0,0],vec4[\[Pi]/2,ArcCos[-(1/3)],0],vec4[\[Pi]/2,ArcCos[-(1/3)],1 (2\[Pi])/3],vec4[\[Pi]/2,ArcCos[-(1/3)],2 (2\[Pi])/3]};
sanity=Map[Vectors4DSP4[[#[[1]]]] . Vectors4DSP4[[#[[2]]]]&,Subsets[{1,2,3,4},{2}]];
If[Not@AllTrue[(sanity//N),#==(-(1/3)//N)&],Print["Sanity check failed!"];Abort[];];

SymmetricPoint4DP4cosp1=vec4[ArcCos[Symbol["cos1"]],ArcCos[Symbol["cos2"]],Symbol["phi"]] . Vectors4DSP4[[1]]//FullSimplify;
SymmetricPoint4DP4cosp2=vec4[ArcCos[Symbol["cos1"]],ArcCos[Symbol["cos2"]],Symbol["phi"]] . Vectors4DSP4[[2]]//FullSimplify;
SymmetricPoint4DP4cosp3=vec4[ArcCos[Symbol["cos1"]],ArcCos[Symbol["cos2"]],Symbol["phi"]] . Vectors4DSP4[[3]]//FullSimplify;
SymmetricPoint4DP4cosp4=vec4[ArcCos[Symbol["cos1"]],ArcCos[Symbol["cos2"]],Symbol["phi"]] . Vectors4DSP4[[4]]//FullSimplify;

SymmetricPoint4DP4Code="const "<>computeType<>" cosp1q = "<>CodeForm[SymmetricPoint4DP4cosp1,computeType]<>";\n"<>
"const "<>computeType<>" cosp2q = "<>CodeForm[SymmetricPoint4DP4cosp2,computeType]<>";\n"<>
"const "<>computeType<>" cosp3q = "<>CodeForm[SymmetricPoint4DP4cosp3,computeType]<>";\n"<>
"const "<>computeType<>" cosp4q = "<>CodeForm[SymmetricPoint4DP4cosp4,computeType]<>";";
Return[SymmetricPoint4DP4Code];
];


DeclareSymmetricPoints4DP3[computeType_String:"double"]:=Module[
{vec4,Vectors4DSP3,sanity,
SymmetricPoint4DP3cosp1,SymmetricPoint4DP3cosp2,SymmetricPoint4DP3cosp3,SymmetricPoint4DP3Code
},

vec4[\[CapitalTheta]1_,\[CapitalTheta]2_,\[Phi]_]:={Cos[\[CapitalTheta]1],Sin[\[CapitalTheta]1]Cos[\[CapitalTheta]2],Sin[\[CapitalTheta]1]Sin[\[CapitalTheta]2]Cos[\[Phi]],Sin[\[CapitalTheta]1]Sin[\[CapitalTheta]2]Sin[\[Phi]]};

Vectors4DSP3={vec4[0,0,0],vec4[(2\[Pi])/3,0,0],vec4[(2\[Pi])/3,\[Pi],0]};
sanity=Map[Vectors4DSP3[[#[[1]]]] . Vectors4DSP3[[#[[2]]]]&,Subsets[{1,2,3},{2}]];
If[Not@AllTrue[(sanity//N),#==(-(1/2)//N)&],Print["Sanity check failed!"];Abort[];];

SymmetricPoint4DP3cosp1=vec4[ArcCos[Symbol["cos1"]],ArcCos[Symbol["cos2"]],Symbol["phi"]] . Vectors4DSP3[[1]]//FullSimplify;
SymmetricPoint4DP3cosp2=vec4[ArcCos[Symbol["cos1"]],ArcCos[Symbol["cos2"]],Symbol["phi"]] . Vectors4DSP3[[2]]//FullSimplify;
SymmetricPoint4DP3cosp3=vec4[ArcCos[Symbol["cos1"]],ArcCos[Symbol["cos2"]],Symbol["phi"]] . Vectors4DSP3[[3]]//FullSimplify;

SymmetricPoint4DP3Code="const "<>computeType<>" cosp1q = "<>CodeForm[SymmetricPoint4DP3cosp1,computeType]<>";\n"<>
"const "<>computeType<>" cosp2q = "<>CodeForm[SymmetricPoint4DP3cosp2,computeType]<>";\n"<>
"const "<>computeType<>" cosp3q = "<>CodeForm[SymmetricPoint4DP3cosp3,computeType]<>";";
Return[SymmetricPoint4DP3Code];
];


(* ::Input::Initialization:: *)
DeclareSymmetricPoints3DP3[computeType_String:"double"]:=Module[
{vec3,Vectors3DSP3,sanity,
SymmetricPoint3DP3cosp1,SymmetricPoint3DP3cosp2,SymmetricPoint3DP3cosp3,SymmetricPoint3DP3Code
},

vec3[\[CapitalTheta]_,\[Phi]_]:={Sin[\[CapitalTheta]]Cos[\[Phi]],Sin[\[CapitalTheta]]Sin[\[Phi]],Cos[\[CapitalTheta]]};

Vectors3DSP3={vec3[\[Pi]/2,0],vec3[\[Pi]/2,1 (2\[Pi])/3],vec3[\[Pi]/2,2 (2\[Pi])/3]};
sanity=Map[Vectors3DSP3[[#[[1]]]] . Vectors3DSP3[[#[[2]]]]&,Subsets[{1,2,3},{2}]];
If[Not@AllTrue[(sanity//N),#==(-(1/2)//N)&],Print["Sanity check failed!"];Abort[];];

SymmetricPoint3DP3cosp1=vec3[ArcCos[Symbol["cos1"]],Symbol["phi"]] . Vectors3DSP3[[1]]//FullSimplify;
SymmetricPoint3DP3cosp2=vec3[ArcCos[Symbol["cos1"]],Symbol["phi"]] . Vectors3DSP3[[2]]//FullSimplify;
SymmetricPoint3DP3cosp3=vec3[ArcCos[Symbol["cos1"]],Symbol["phi"]] . Vectors3DSP3[[3]]//FullSimplify;

SymmetricPoint3DP3Code="const "<>computeType<>" cosp1q = "<>CodeForm[SymmetricPoint3DP3cosp1,computeType]<>";\n"<>
"const "<>computeType<>" cosp2q = "<>CodeForm[SymmetricPoint3DP3cosp2,computeType]<>";\n"<>
"const "<>computeType<>" cosp3q = "<>CodeForm[SymmetricPoint3DP3cosp3,computeType]<>";";
Return[SymmetricPoint3DP3Code];
];


DeclareSymmetricPoints3DP4[computeType_String:"double"]:=Module[
{vec3,sanity,Vectors3DSP4,
SymmetricPoint3DP4cosp1,SymmetricPoint3DP4cosp2,SymmetricPoint3DP4cosp3,SymmetricPoint3DP4cosp4,SymmetricPoint3DP4Code
},

vec3[\[CapitalTheta]_,\[Phi]_]:={Sin[\[CapitalTheta]]Cos[\[Phi]],Sin[\[CapitalTheta]]Sin[\[Phi]],Cos[\[CapitalTheta]]};

Vectors3DSP4={vec3[0,0],vec3[ArcCos[-(1/3)],0],vec3[ArcCos[-(1/3)],1 (2\[Pi])/3],vec3[ArcCos[-(1/3)],2 (2\[Pi])/3]};
sanity=Map[Vectors3DSP4[[#[[1]]]] . Vectors3DSP4[[#[[2]]]]&,Subsets[{1,2,3,4},{2}]];
If[Not@AllTrue[(sanity//N),#==(-(1/3)//N)&],Print["Sanity check failed!"];Abort[];];

SymmetricPoint3DP4cosp1=vec3[ArcCos[Symbol["cos1"]],Symbol["phi"]] . Vectors3DSP4[[1]]//FullSimplify;
SymmetricPoint3DP4cosp2=vec3[ArcCos[Symbol["cos1"]],Symbol["phi"]] . Vectors3DSP4[[2]]//FullSimplify;
SymmetricPoint3DP4cosp3=vec3[ArcCos[Symbol["cos1"]],Symbol["phi"]] . Vectors3DSP4[[3]]//FullSimplify;
SymmetricPoint3DP4cosp4=vec3[ArcCos[Symbol["cos1"]],Symbol["phi"]] . Vectors3DSP4[[4]]//FullSimplify;

SymmetricPoint3DP4Code="const "<>computeType<>" cosp1q = "<>CodeForm[SymmetricPoint3DP4cosp1,computeType]<>";\n"<>
"const "<>computeType<>" cosp2q = "<>CodeForm[SymmetricPoint3DP4cosp2,computeType]<>";\n"<>
"const "<>computeType<>" cosp3q = "<>CodeForm[SymmetricPoint3DP4cosp3,computeType]<>";\n"<>
"const "<>computeType<>" cosp4q = "<>CodeForm[SymmetricPoint3DP4cosp4,computeType]<>";";
Return[SymmetricPoint3DP4Code];
];


(* ::Input::Initialization:: *)
DeclareSymmetricPoints2DP3[computeType_String:"double"]:=Module[
{vec2,Vectors3DSP3,sanity,
SymmetricPoint3DP3cosp1,SymmetricPoint3DP3cosp2,SymmetricPoint3DP3cosp3,SymmetricPoint3DP3Code
},

vec2[\[CapitalTheta]_]:={Cos[\[CapitalTheta]],Sin[\[CapitalTheta]]};

Vectors3DSP3={vec2[0],vec2[1 (2\[Pi])/3],vec2[2 (2\[Pi])/3]};
sanity=Map[Vectors3DSP3[[#[[1]]]] . Vectors3DSP3[[#[[2]]]]&,Subsets[{1,2,3},{2}]];
If[Not@AllTrue[(sanity//N),#==(-(1/2)//N)&],Print["Sanity check failed!"];Abort[];];

SymmetricPoint3DP3cosp1=vec2[ArcCos[Symbol["cos1"]]] . Vectors3DSP3[[1]]//FullSimplify;
SymmetricPoint3DP3cosp2=vec2[ArcCos[Symbol["cos1"]]] . Vectors3DSP3[[2]]//FullSimplify;
SymmetricPoint3DP3cosp3=vec2[ArcCos[Symbol["cos1"]]] . Vectors3DSP3[[3]]//FullSimplify;

SymmetricPoint3DP3Code="const "<>computeType<>" cosp1q = "<>CodeForm[SymmetricPoint3DP3cosp1,computeType]<>";\n"<>
"const "<>computeType<>" cosp2q = "<>CodeForm[SymmetricPoint3DP3cosp2,computeType]<>";\n"<>
"const "<>computeType<>" cosp3q = "<>CodeForm[SymmetricPoint3DP3cosp3,computeType]<>";";
Return[SymmetricPoint3DP3Code];
];


DeclareSymmetricPoints2DP4[computeType_String:"double"]:=Module[
{vec2,sanity,Vectors3DSP4,
SymmetricPoint3DP4cosp1,SymmetricPoint3DP4cosp2,SymmetricPoint3DP4cosp3,SymmetricPoint3DP4cosp4,SymmetricPoint3DP4Code
},

vec2[\[CapitalTheta]_]:={Cos[\[CapitalTheta]],Sin[\[CapitalTheta]]};

Vectors3DSP4={vec2[0],vec2[1 (2\[Pi])/4],vec2[2 (2\[Pi])/4],vec2[3 (2\[Pi])/4]};
sanity=Map[Vectors3DSP4[[#[[1]]]] . Vectors3DSP4[[#[[2]]]]&,Subsets[{1,2,3,4},{2}]];

SymmetricPoint3DP4cosp1=vec2[ArcCos[Symbol["cos1"]]] . Vectors3DSP4[[1]]//FullSimplify;
SymmetricPoint3DP4cosp2=vec2[ArcCos[Symbol["cos1"]]] . Vectors3DSP4[[2]]//FullSimplify;
SymmetricPoint3DP4cosp3=vec2[ArcCos[Symbol["cos1"]]] . Vectors3DSP4[[3]]//FullSimplify;
SymmetricPoint3DP4cosp4=vec2[ArcCos[Symbol["cos1"]]] . Vectors3DSP4[[4]]//FullSimplify;

SymmetricPoint3DP4Code="const "<>computeType<>" cosp1q = "<>CodeForm[SymmetricPoint3DP4cosp1,computeType]<>";\n"<>
"const "<>computeType<>" cosp2q = "<>CodeForm[SymmetricPoint3DP4cosp2,computeType]<>";\n"<>
"const "<>computeType<>" cosp3q = "<>CodeForm[SymmetricPoint3DP4cosp3,computeType]<>";\n"<>
"const "<>computeType<>" cosp4q = "<>CodeForm[SymmetricPoint3DP4cosp4,computeType]<>";";
Return[SymmetricPoint3DP4Code];
];


(* ::Input::Initialization:: *)
KernelPrepend="";


codeOptimizeFunctions={};
AddCodeOptimizeFunctions[expr___]:=Module[{list},
list={expr};
codeOptimizeFunctions=Union[codeOptimizeFunctions,list];
]
ClearCodeOptimizeFunctions[]:=Module[{},
codeOptimizeFunctions={};
]
ShowCodeOptimizeFunctions[]:=Module[{},
Print["Functions to be optimized for call count are: ",Dataset[codeOptimizeFunctions,MaxItems->20000]];
]


useKernelOptimizations=True;
UseKernelOptimizations[yn_/;Element[yn,Booleans]]:=Module[{},useKernelOptimizations=yn;]


KernelParamIsInterpolator[expr_Association]:=(expr["Type"]!="Variable")&&(expr["Type"]!="Constant")&&(expr["Type"]!="ComplexVariable")&&(expr["Type"]!="ComplexConstant");


GetOptimizedKernelCode[equation_/;Head[equation]=!=List,kernelParameterList_List,computeType_String]:=Module[{optList,interpObj,replacementObj,replacementNames,replacements,definitions,returnStatement},
If[Not@IsValidParameterList[parameterList],Print["DiFfRG::CodeTools::GetOptimizedKernelCode: Invalid parameter List!"];Abort[]];

If[Not[useKernelOptimizations],
Return["    // flow\n    return "<>CodeForm[equation,computeType]<>";"]
];
optList=Map[Symbol[#["Name"]][__]&,Select[kernelParameterList,KernelParamIsInterpolator]]\[Union]codeOptimizeFunctions;
interpObj=Flatten[Map[Cases[equation,#,Infinity]&,optList]];
replacementObj=Keys@Select[Counts[interpObj],#>1&];
replacementNames=Table["DiFfRGREPL"<>ToString[i],{i,1,Length[replacementObj]}];
replacements=Table[replacementObj[[i]]->replacementNames[[i]],{i,1,Length[replacementObj]}];
definitions=If[Length[replacementObj]>0,"    // optimization definitions\n"<>StringJoin[Table["const "<>computeType<>" "<>ToString[replacementNames[[i]]]<>" = "<>CodeForm[replacementObj[[i]],computeType]<>";\n",{i,1,Length[replacementObj]}]]<>"\n",""];
returnStatement="    // flow\n    return "<>CodeForm[equation//.replacements,computeType]<>";";
definitions<>returnStatement
];
GetOptimizedKernelCode[equations_List,kernelParameterList_List,computeType_String]:=Module[{optList,interpObj,replacementObj,replacementNames,replacements,definitions,partNames,parts,returnStatement},
If[Not@IsValidParameterList[parameterList],Print["DiFfRG::CodeTools::GetOptimizedKernelCode: Invalid parameter List!"];Abort[]];
If[Not[useKernelOptimizations],
partNames=Table["DiFfRGPart"<>ToString[i],{i,1,Length[equations]}];
parts="    // flows\n"<>StringJoin[Table["const auto "<>partNames[[i]]<>" = "<>CodeForm[equations[[i]],computeType]<>";\n",{i,1,Length[equations]}]];

returnStatement="    // sum of flows\n    return "<>StringDrop[StringJoin[Table[partNames[[i]]<>" + ",{i,1,Length[equations]}]],-3]<>";";
Return[parts<>returnStatement];
];

optList=Map[Symbol[#["Name"]][__]&,Select[kernelParameterList,KernelParamIsInterpolator]]\[Union]codeOptimizeFunctions;
interpObj=Flatten[Map[Cases[equations,#,Infinity]&,optList]];
replacementObj=Keys@Select[Counts[interpObj],#>1&];
replacementNames=Table["DiFfRGREPL"<>ToString[i],{i,1,Length[replacementObj]}];
replacements=Table[replacementObj[[i]]->replacementNames[[i]],{i,1,Length[replacementObj]}];
definitions=If[Length[replacementObj]>0,"    // optimization definitions\n"<>StringJoin[Table["const "<>computeType<>" "<>ToString[replacementNames[[i]]]<>" = "<>CodeForm[replacementObj[[i]],computeType]<>";\n",{i,1,Length[replacementObj]}]]<>"\n",""];

partNames=Table["DiFfRGPart"<>ToString[i],{i,1,Length[equations]}];
parts="    // flows\n"<>StringJoin[Table["const auto "<>ToString[partNames[[i]]]<>" = "<>CodeForm[equations[[i]]//.replacements,computeType]<>";\n",{i,1,Length[equations]}]]<>"\n";

returnStatement="    // sum of flows\n    return "<>StringDrop[StringJoin[Table[ToString[partNames[[i]]]<>" + ",{i,1,Length[equations]}]],-3]<>";";
definitions<>parts<>returnStatement
];


IndentCode[code_String,level_Integer]:=StringJoin[Table["  ",{i,1,level}]]<>StringReplace[code,"\n"->"\n"<>StringJoin[Table["  ",{i,1,level}]]]


$StandardKernelDefinitions="
static __forceinline__ __device__ __host__ auto RB(const auto k2, const auto p2) { return REG::RB(k2, p2); }
static __forceinline__ __device__ __host__ auto RF(const auto k2, const auto p2) { return REG::RF(k2, p2); }

static __forceinline__ __device__ __host__ auto RBdot(const auto k2, const auto p2) { return REG::RBdot(k2, p2); }
static __forceinline__ __device__ __host__ auto RFdot(const auto k2, const auto p2) { return REG::RFdot(k2, p2); }

static __forceinline__ __device__ __host__ auto dq2RB(const auto k2, const auto p2) { return REG::dq2RB(k2, p2); }
static __forceinline__ __device__ __host__ auto dq2RF(const auto k2, const auto p2) { return REG::dq2RF(k2, p2); }
";
$KernelDefinitions=$StandardKernelDefinitions;
SetKernelDefinitions[definitionCode_String]:=Module[{},
Set[$KernelDefinitions,definitionCode];
]
SetKernelDefinitions[]:=Module[{},
Set[$KernelDefinitions,$StandardKernelDefinitions];
]
ShowKernelDefinitions[]:=Print[$KernelDefinitions]


(* ::Input::Initialization:: *)
Options[MakeFlowClass] = {"Regulator"->"PolynomialExpRegulator","RegulatorOptionCode"->{"",""}}
MakeFlowClass[name_String,kernels_List,OptionsPattern[]]:=
Module[{includeList,integratorList,hhDef,hhFlow,ccFlow,regulatorPrefix,regulatorParameters,regulatorOpts,regulator},
If[Not@IsValidKernelSpecList[kernels],Print["Invalid kernels list!"];Abort[]];
regulatorOpts = OptionValue["RegulatorOptionCode"];
regulator= OptionValue["Regulator"];

If[Not@StringQ[regulatorOpts[[1]]]||Not@StringQ[regulatorOpts[[2]]],Print["Invalid regulator options!"];Abort[]];

If[name=="",Print["Please provide a valid name to MakeFlowClass."];Abort[]];
integratorList=kernels;
includeList=StringJoin[Map["#include \""<>#["Path"]<>"/"<>#["Name"]<>".hh\"\n"&,kernels]];

regulatorParameters=regulatorOpts[[1]];
regulatorPrefix=regulatorOpts[[2]];

hhDef="#pragma once

#include <DiFfRG/common/utils.hh>
#include <DiFfRG/physics/integration.hh>
#include <DiFfRG/physics/interpolation.hh>
#include <DiFfRG/physics/regulators.hh>
#include <DiFfRG/physics/thermodynamics.hh>

using namespace ::DiFfRG;

"<>regulatorPrefix<>"
#define __REGULATOR__ ::DiFfRG::"<>regulator<>"<"<>regulatorParameters<>">
";
hhFlow="#pragma once

"<>includeList<>"

#include \"def.hh\"
#include <DiFfRG/physics/flow_equations.hh>

class "<>name<>"FlowEquations : public FlowEquations
{
public:
  "<>name<>"FlowEquations(const JSONValue& json);

private:
  const std::array<uint, 1> grid_size_int;
  const std::array<uint, 2> grid_sizes_angle_int;
  const std::array<uint, 3> grid_sizes_3D_int;
  const std::array<uint, 4> grid_sizes_4D_int;

  const std::array<uint, 2> grid_sizes_2D_cartesian_int;
  const std::array<uint, 3> grid_sizes_3D_cartesian_int;

public:
  ::DiFfRG::QuadratureProvider quadrature_provider;"<>
StringJoin[Map["\n  ::DiFfRG::Flows::"<>#["Name"]<>"_integrator "<>#["Name"]<>"_integrator;"&,integratorList]]<>"
};";

ccFlow="#include \"flows.hh\"

"<>name<>"FlowEquations::"<>name<>"FlowEquations(const JSONValue& json)
  : FlowEquations(json, [](double x) { return powr<-1>(x + __REGULATOR__::RB(1., x)) * __REGULATOR__::RBdot(1., x); }),

                      grid_size_int{{x_quadrature_order}},
                      grid_sizes_angle_int{{x_quadrature_order, 2 * angle_quadrature_order}},
                      grid_sizes_3D_int{{x_quadrature_order, angle_quadrature_order, angle_quadrature_order}},
                      grid_sizes_4D_int{{x_quadrature_order, angle_quadrature_order, angle_quadrature_order, angle_quadrature_order}},

                      grid_sizes_2D_cartesian_int{{x_quadrature_order, x_quadrature_order}},
                      grid_sizes_3D_cartesian_int{{x_quadrature_order, x_quadrature_order, x_quadrature_order}},

                      quadrature_provider(json)
"<>
StringJoin[Map[",\n                      "<>#["Name"]<>"_integrator(quadrature_provider, "<>GridSelector[#]<>", x_extent, json)"&,integratorList]]<>"
{
}
";

ExportCode[flowDir<>"def.hh",hhDef];
ExportCode[flowDir<>"flows.hh",hhFlow];
ExportCode[flowDir<>"flows.cc",ccFlow];
MakeCMakeFile[kernels];
];


(* ::Input::Initialization:: *)
Options[MakeFlowClassFiniteT] = {"Regulator"->"PolynomialExpRegulator","RegulatorOptionCode"->{"",""}}
MakeFlowClassFiniteT[name_String,kernels_List,OptionsPattern[]]:=Module[{includeList,
integratorList,integratorq0List,integratorx0List,regulatorOpts,regulator,
hhDef,hhFlow,ccFlow,regulatorPrefix,regulatorParameters},
If[Not@IsValidKernelSpecList[kernels],Print["DiFfRG::CodeTools::MakeFlowClassFiniteT: Invalid kernels list!"];Abort[]];
regulatorOpts = OptionValue["RegulatorOptionCode"];
regulator= OptionValue["Regulator"];

If[Not@StringQ[regulatorOpts[[1]]]||Not@StringQ[regulatorOpts[[2]]],Print["DiFfRG::CodeTools::MakeFlowClassFiniteT: Invalid regulator options!"];Abort[]];

If[name=="",Print["DiFfRG::CodeTools::MakeFlowClassFiniteT: Please provide a valid name to MakeFlowClass."];Abort[]];

integratorList=Select[kernels,#["Type"]=="Quadrature"&];
integratorq0List=Select[kernels,#["Type"]=="Quadratureq0"&];
integratorx0List=Select[kernels,#["Type"]=="Quadraturex0"&];

includeList=StringJoin[Map["#include \""<>#["Path"]<>"/"<>#["Name"]<>".hh\"\n"&,kernels]];

regulatorParameters=regulatorOpts[[1]];
regulatorPrefix=regulatorOpts[[2]];

hhDef="#pragma once

#include <DiFfRG/common/utils.hh>
#include <DiFfRG/physics/integration.hh>
#include <DiFfRG/physics/integration_finiteT.hh>
#include <DiFfRG/physics/interpolation.hh>
#include <DiFfRG/physics/regulators.hh>
#include <DiFfRG/physics/thermodynamics.hh>

using namespace ::DiFfRG;

"<>regulatorPrefix<>"
#define __REGULATOR__ ::DiFfRG::"<>regulator<>"<"<>regulatorParameters<>">
";
hhFlow="#pragma once

"<>includeList<>"

#include \"def.hh\"
#include <DiFfRG/physics/flow_equations.hh>

class "<>name<>"FlowEquations : public FlowEquationsFiniteT
{
public:
  "<>name<>"FlowEquations(const JSONValue& json);

private:
  const std::array<uint, 1> grid_size_int;
  const std::array<uint, 2> grid_sizes_angle_int;
  const std::array<uint, 3> grid_sizes_3D_int;
  const std::array<uint, 4> grid_sizes_4D_int;

  const std::array<uint, 2> grid_sizes_int_fT;
  const std::array<uint, 3> grid_sizes_angle_int_fT;
  const std::array<uint, 4> grid_sizes_4D_int_fT;

  const std::array<uint, 2> grid_sizes_2D_cartesian_int;
  const std::array<uint, 3> grid_sizes_3D_cartesian_int;

public:
  QuadratureProvider quadrature_provider;"<>
StringJoin[Map["\n  Flows::"<>#["Name"]<>"_integrator "<>#["Name"]<>"_integrator;"&,Join[integratorList,integratorx0List,integratorq0List]]]<>"
};";

ccFlow="#include \"flows.hh\"

"<>name<>"FlowEquations::"<>name<>"FlowEquations(const JSONValue& json)
  : FlowEquationsFiniteT(json, json.get_double(\"/physical/T\"),

                    [&](double q2) { return 1. / (q2 + __REGULATOR__::RB(powr<2>(k), q2)) * __REGULATOR__::RBdot(powr<2>(k), q2); },
                    [&](double q0) { return 1. / (powr<2>(q0) + __REGULATOR__::RB(powr<2>(k), powr<2>(q0))) * __REGULATOR__::RBdot(powr<2>(k), powr<2>(q0)); }, 
                    [&](double q0) { return 1. / powr<2>(powr<2>(q0) + powr<2>(k)); }),

                    grid_size_int{{x_quadrature_order}},
                    grid_sizes_angle_int{{x_quadrature_order, angle_quadrature_order}},
                    grid_sizes_3D_int{{x_quadrature_order, angle_quadrature_order, angle_quadrature_order}},
                    grid_sizes_4D_int{{x_quadrature_order, angle_quadrature_order, angle_quadrature_order, angle_quadrature_order}},

                    grid_sizes_int_fT{{x_quadrature_order, x0_quadrature_order}},
                    grid_sizes_angle_int_fT{{x_quadrature_order, angle_quadrature_order, x0_quadrature_order}},
                    grid_sizes_4D_int_fT{{x_quadrature_order, angle_quadrature_order, angle_quadrature_order, x0_quadrature_order}},

                    grid_sizes_2D_cartesian_int{{x_quadrature_order, x_quadrature_order}},
                    grid_sizes_3D_cartesian_int{{x_quadrature_order, x_quadrature_order, x_quadrature_order}},

                    quadrature_provider(json)
"<>
StringJoin[Map[",\n                      "<>#["Name"]<>"_integrator(quadrature_provider, grid_size_int, x_extent, json)"&,integratorList]]<>
StringJoin[Map[",\n                      "<>#["Name"]<>"_integrator(quadrature_provider, "<>GridSelectorFiniteT[#["Angles"]]<>", x_extent, x0_extent, x0_summands, json)"&,integratorx0List]]<>
StringJoin[Map[",\n                      "<>#["Name"]<>"_integrator(quadrature_provider, "<>GridSelector[#]<>", x_extent, json)"&,integratorq0List]]<>"
{
}
";

ExportCode[flowDir<>"def.hh",hhDef];
ExportCode[flowDir<>"flows.hh",hhFlow];
ExportCode[flowDir<>"flows.cc",ccFlow];
MakeCMakeFile[kernels];
];


$codeParser="Cpp";
SetCodeParser[str_String]:=Set[$codeParser,str]


(* ::Input::Initialization:: *)
MakeKernelClass[kernel_Association,parameterList_List,integrandFlow_,constantFlow_,integrandDefinitions_String,constantDefinitions_String]:=Module[
{computeType,integrationVariables},

If[Not@IsValidKernelSpec[kernel],Print["DiFfRG::CodeTools::MakeKernelClass: Invalid kernel!"];Abort[]];
If[Not@IsValidParameterList[parameterList],Print["DiFfRG::CodeTools::MakeKernelClass: Invalid parameter List!"];Abort[]];

computeType=kernel["ctype"];

If[kernel["Angles"]<0,Print["DiFfRG::CodeTools::MakeKernelClass: T = 0 kernel cannot have < 0 angles!"];Abort[]];

If[kernel["Type"]==="Constant",
integrationVariables={},
If[kernel["Type"]==="CartesianQuadrature",
If[kernel["Angles"]!=0,Print["Cartesian integrator cannot have angles!"];Abort[];];
Switch[kernel["d"],
1,integrationVariables={"q"},
2,integrationVariables={"qx","qy"},
3,integrationVariables={"qx","qy","qz"},
_,Print["Cartesian integrator for dimension "<>ToString[kernel["d"]]<>" not implemented!"];Abort[];
],
If[kernel["Angles"]==0,integrationVariables={"q"}];
If[kernel["Angles"]==1,integrationVariables={"q","cos1"}];
If[kernel["Angles"]==2&&kernel["d"]==4,integrationVariables={"q","cos1","cos2"}];
If[kernel["Angles"]==2&&kernel["d"]!=4,integrationVariables={"q","cos1","phi"}];
If[kernel["Angles"]==3,integrationVariables={"q","cos1","cos2","phi"}];
If[kernel["Angles"]>3,Print["DiFfRG::CodeTools::MakeKernelClass: T = 0 kernel cannot have > 3 angles!"];Abort[]];
];
];

ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>kernel["Name"]<>".kernel",Global`CreateKernelClass[ToString[kernel["Name"]]<>"_kernel",integrandFlow,constantFlow,"integrandBody"->integrandDefinitions,"constantBody"->constantDefinitions,"integrationVariables"->integrationVariables,"parameters"->Join[{<|"Name"->"k"|>},parameterList],"CodeParser"->$codeParser]
];
];


MakeIntegratorTypes[kernel_Association]:=Module[{computeType,kernelName,suffix,integrator,integratorAD},
If[Not@IsValidKernelSpec[kernel],Print["Invalid kernel!"];Abort[]];

computeType=kernel["ctype"];

kernelName=ToString[kernel["Name"]]<>"_kernel";

suffix=Switch[kernel["Type"],
"QMC","QMC",
"Constant",If[kernel["Angles"]=!=0,Print["Constant integrator cannot have angles!"];Abort[]];"Constant",
"Quadrature",DeviceChoice[kernel["Device"]],
"CartesianQuadrature",If[kernel["Angles"]=!=0,Print["Cartesian integrator cannot have angles!"];Abort[]];"Cartesian"<>DeviceChoice[kernel["Device"]],
_,Print["Unknown integration type "<>kernel["Type"]<>"!"];Abort[]
];

If[kernel["Type"]=="CartesianQuadrature",
integrator="DiFfRG::Integrator"<>ToString[kernel["d"]]<>"D"<>suffix<>"<"<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::Integrator"<>ToString[kernel["d"]]<>"D"<>suffix<>"<"<>"autodiff::real, "<>kernelName<>"<__REGULATOR__>>" ,

Switch[kernel["Angles"],
0,
integrator="DiFfRG::Integrator"<>suffix<>"<"<>ToString[kernel["d"]]<>", "<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::Integrator"<>suffix<>"<"<>ToString[kernel["d"]]<>", autodiff::real, "<>kernelName<>"<__REGULATOR__>>" ,

1,
integrator="DiFfRG::IntegratorAngle"<>suffix<>"<"<>ToString[kernel["d"]]<>", "<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::IntegratorAngle"<>suffix<>"<"<>ToString[kernel["d"]]<>", autodiff::real, "<>kernelName<>"<__REGULATOR__>>" ,

2,
If[kernel["d"]!=3&&kernel["d"]!=4,Print["Inconsistent dimensions!"];Abort[]];
If[kernel["d"]==3,
integrator="DiFfRG::Integrator3D"<>suffix<>"<"<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::Integrator3D"<>suffix<>"<autodiff::real, "<>kernelName<>"<__REGULATOR__>>" ;
,
integrator="DiFfRG::Integrator4D2Ang"<>suffix<>"<"<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::Integrator4D2Ang"<>suffix<>"<autodiff::real, "<>kernelName<>"<__REGULATOR__>>" ;
],

3,
If[kernel["d"]!=4,Print["Inconsistent dimensions!"];Abort[]];
integrator="DiFfRG::Integrator4D"<>suffix<>"<"<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::Integrator4D"<>suffix<>"<autodiff::real, "<>kernelName<>"<__REGULATOR__>>" 
];
];

{integrator,integratorAD}
];


(* ::Input::Initialization:: *)
MakeKernelIntegrator[kernel_Association,parameterList_List]:=
Module[{computeType,kernelName,className,integrator,integratorAD,gridSizes,argList,paramList,paramListAD,kernelFile,hhFile,ccFile,cuFile,hh,cc,cu},
If[Not@IsValidKernelSpec[kernel],Print["Invalid kernel!"];Abort[]];
If[Not@IsValidParameterList[parameterList],Print["Invalid parameter List!"];Abort[]];

computeType=kernel["ctype"];

kernelName=ToString[kernel["Name"]]<>"_kernel";
className=ToString[kernel["Name"]]<>"_integrator"; 

{integrator,integratorAD}=MakeIntegratorTypes[kernel];

gridSizes=If[kernel["Type"]=!="CartesianQuadrature",
kernel["Angles"]+1,
kernel["d"]
];

argList=StringDrop[StringJoin[Table[""<>ToString[parameterList[[i]]["Name"]]<>", ",{i,1,Length[parameterList]}]],-2];
paramList=StringDrop[StringJoin[Table["const "<>CppType[computeType][parameterList[[i]]["Type"]]<>ArgType[parameterList[[i]]["Type"]]<>" "<>ToString[parameterList[[i]]["Name"]]<>", ",{i,1,Length[parameterList]}]],-2];
paramListAD=StringDrop[StringJoin[Table[
If[
KeyExistsQ[parameterList[[i]],"AD"]&&parameterList[[i]]["AD"]==True,
"const "<>CppTypeAD[computeType][parameterList[[i]]["Type"]]<>ArgType[parameterList[[i]]["Type"]]<>" "<>ToString[parameterList[[i]]["Name"]]<>", ",
"const "<>CppType[computeType][parameterList[[i]]["Type"]]<>ArgType[parameterList[[i]]["Type"]]<>" "<>ToString[parameterList[[i]]["Name"]]<>", "]
,{i,1,Length[parameterList]}
]],-2];

kernelFile=kernel["Name"]<>".kernel";
hhFile=kernel["Name"]<>".hh";
ccFile=kernel["Name"]<>".cc";
cuFile=kernel["Name"]<>".cu";

hh="#pragma once

template <typename REG> class "<>kernelName<>";
#include \"../def.hh\"

#include <memory>
#include <future>

namespace DiFfRG
{
  namespace Flows
  {
    class "<>className<>"
    {
    public:
      "<>className<>"(QuadratureProvider &quadrature_provider, std::array<uint, "<>ToString[gridSizes]<>"> grid_sizes, const "<>computeType<>" x_extent, const JSONValue& json);
      "<>className<>"(const "<>className<>"& other);
      ~"<>className<>"();

      template<typename NT, typename... T>
      std::future<NT> request(T&&... t)
      {"<>
If[kernel["AD"],"
        static_assert(std::is_same_v<NT, "<>computeType<>"> || std::is_same_v<NT, autodiff::real>, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return request_CT(std::forward<T>(t)...);
        else if constexpr(std::is_same_v<NT, autodiff::real>)
          return request_AD(std::forward<T>(t)...);","
        static_assert(std::is_same_v<NT, "<>computeType<>">, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return request_CT(std::forward<T>(t)...);"
]<>"
      }

      template<typename NT, typename... T>
      NT get(T&&... t)
      {"<>
If[kernel["AD"],"
        static_assert(std::is_same_v<NT, "<>computeType<>"> || std::is_same_v<NT, autodiff::real>, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return get_CT(std::forward<T>(t)...);
        else if constexpr(std::is_same_v<NT, autodiff::real>)
          return get_AD(std::forward<T>(t)...);","
        static_assert(std::is_same_v<NT, "<>computeType<>">, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return get_CT(std::forward<T>(t)...);"
]<>"
      }

    private:
      std::future<"<>computeType<>"> request_CT(const "<>computeType<>" k, "<>paramList<>");
      "<>computeType<>" get_CT(const "<>computeType<>" k, "<>paramList<>");"<>
If[kernel["AD"],"
      std::future<autodiff::real> request_AD(const "<>computeType<>" k, "<>paramListAD<>");
      autodiff::real get_AD(const "<>computeType<>" k, "<>paramListAD<>");",
""
]<>"

      QuadratureProvider& quadrature_provider;
      const std::array<uint, "<>ToString[gridSizes]<>"> grid_sizes;
      std::array<uint, "<>ToString[gridSizes]<>"> jac_grid_sizes;
      const "<>computeType<>" x_extent;
      const "<>computeType<>" jacobian_quadrature_factor;
	  const JSONValue json;

      std::unique_ptr<"<>integrator<>"> integrator;"<>
If[kernel["AD"],"
      std::unique_ptr<"<>integratorAD<>"> integrator_AD;",
""
]<>"
    };
  } // namespace Flows
} // namespace DiFfRG";

cc="#include \""<>cuFile<>"\"";
cu="#define FLOW_CODE

#include \""<>hhFile<>"\"
#include \""<>kernelFile<>"\"

namespace DiFfRG
{
  namespace Flows
  {
    "<>className<>"::"<>className<>"(QuadratureProvider &quadrature_provider, std::array<uint, "<>ToString[gridSizes]<>"> grid_sizes, const "<>computeType<>" x_extent, const JSONValue& json)
        : quadrature_provider(quadrature_provider), grid_sizes(grid_sizes), x_extent(x_extent), jacobian_quadrature_factor(json.get_double(\"/integration/jacobian_quadrature_factor\")), json(json)
    {
      integrator = std::make_unique<"<>integrator<>">(quadrature_provider, grid_sizes, x_extent, json);"<>
If[kernel["AD"],"
      for(uint i = 0; i < "<>ToString[gridSizes]<>"; ++i)
        jac_grid_sizes[i] = uint(jacobian_quadrature_factor * grid_sizes[i]);
      integrator_AD = std::make_unique<"<>integratorAD<>">(quadrature_provider, jac_grid_sizes, x_extent, json);",
""
]<>"
    }

    "<>className<>"::"<>className<>"(const "<>className<>"& other)
        : quadrature_provider(other.quadrature_provider), grid_sizes(other.grid_sizes), jac_grid_sizes(other.jac_grid_sizes), x_extent(other.x_extent), 
          jacobian_quadrature_factor(other.jacobian_quadrature_factor), json(other.json),
          integrator(std::make_unique<"<>integrator<>">(other.quadrature_provider, other.grid_sizes, other.x_extent, other.json))"<>
If[kernel["AD"],",
          integrator_AD(std::make_unique<"<>integratorAD<>">(other.quadrature_provider, other.jac_grid_sizes, other.x_extent, other.json))",
""
]<>"
    {
    }

    "<>className<>"::~"<>className<>"() = default;

    std::future<"<>computeType<>"> "<>className<>"::request_CT(const "<>computeType<>" k, "<>paramList<>")
    {
      return integrator->request(k, "<>argList<>");
    }

    "<>computeType<>" "<>className<>"::get_CT(const "<>computeType<>" k, "<>paramList<>")
    {
      return integrator->get(k, "<>argList<>");
    }
"<>
If[kernel["AD"],"
    std::future<autodiff::real> "<>className<>"::request_AD(const "<>computeType<>" k, "<>paramListAD<>")
    {
      return integrator_AD->request(k, "<>argList<>");
    }

    autodiff::real "<>className<>"::get_AD(const "<>computeType<>" k, "<>paramListAD<>")
    {
      return integrator_AD->get(k, "<>argList<>");
    }",
""
]<>"
  } // namespace Flows
} // namespace DiFfRG";

ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>hhFile,hh];
ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>ccFile,cc];
ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>cuFile,cu];
];


(* ::Input::Initialization:: *)
MakeKernelClassFiniteT[kernel_Association,parameterList_List,integrandFlow_,constantFlow_,integrandDefinitions_String,constantDefinitions_String]:=Module[
{computeType,integrationVariables},
If[Not@IsValidKernelSpec[kernel],Print["DiFfRG::CodeTools::MakeKernelClassFiniteT: Invalid kernel!"];Abort[]];
If[Not@IsValidParameterList[parameterList],Print["DiFfRG::CodeTools::MakeKernelClassFiniteT: Invalid parameter List!"];Abort[]];

computeType=kernel["ctype"];

If[kernel["Angles"]<0,Print["DiFfRG::CodeTools::MakeKernelClassFiniteT: finite T kernel cannot have < 0 angles!"];Abort[]];
If[kernel["Angles"]==0,integrationVariables={"q","q0"}];
If[kernel["Angles"]==1,integrationVariables={"q","cos1","q0"}];
If[kernel["Angles"]==2,integrationVariables={"q","cos1","phi","q0"}];
If[kernel["Angles"]>2,Print["DiFfRG::CodeTools::MakeKernelClassFiniteT: finite T kernel cannot have > 2 angles!"];Abort[]];

ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>kernel["Name"]<>".kernel",
CreateKernelClass[ToString[kernel["Name"]],integrandFlow,constantFlow,"body"->integrandDefinitions,"integrationVariables"->integrationVariables,"parameters"->parameterList,"CodeParser"->$codeParser]
];
];


(* ::Input::Initialization:: *)
MakeKernelIntegratorFiniteTx0[kernel_Association,parameterList_List]:=
Module[{computeType . kernelName,className,integrator,integratorAD,argList,paramList,paramListAD,kernelFile,hhFile,ccFile,cuFile,hh,cc,cu},
If[Not@IsValidKernelSpec[kernel],Print["DiFfRG::CodeTools::MakeKernelIntegratorFiniteTx0: Invalid kernel!"];Abort[]];
If[Not@IsValidParameterList[parameterList],Print["DiFfRG::CodeTools::MakeKernelIntegratorFiniteTx0: Invalid parameter List!"];Abort[]];

computeType=kernel["ctype"];

kernelName=kernel["Name"]<>"_kernel";
className=kernel["Name"]<>"_integrator"; 

If[kernel["Angles"]==0,
integrator="DiFfRG::IntegratorFiniteTx0"<>DeviceChoice[kernel["Device"]]<>"<"<>ToString[kernel["d"]]<>", "<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::IntegratorFiniteTx0"<>DeviceChoice[kernel["Device"]]<>"<"<>ToString[kernel["d"]]<>", autodiff::real, "<>kernelName<>"<__REGULATOR__>>" 
];
If[kernel["Angles"]==1,
integrator="DiFfRG::IntegratorAngleFiniteTx0"<>DeviceChoice[kernel["Device"]]<>"<"<>ToString[kernel["d"]]<>", "<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::IntegratorAngleFiniteTx0"<>DeviceChoice[kernel["Device"]]<>"<"<>ToString[kernel["d"]]<>", autodiff::real, "<>kernelName<>"<__REGULATOR__>>" 
];
If[kernel["Angles"]==2,
If[kernel["d"]!=4,Print["Inconsistent dimensions!"];Abort[]];
integrator="DiFfRG::Integrator4DFiniteTx0"<>DeviceChoice[kernel["Device"]]<>"<"<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::Integrator4DFiniteTx0"<>DeviceChoice[kernel["Device"]]<>"<autodiff::real, "<>kernelName<>"<__REGULATOR__>>" 
];

argList=StringDrop[StringJoin[Table[""<>ToString[parameterList[[i]]["Name"]]<>", ",{i,1,Length[parameterList]}]],-2];
paramList=StringDrop[StringJoin[Table["const "<>CppType[computeType][parameterList[[i]]["Type"]]<>ArgType[parameterList[[i]]["Type"]]<>" "<>ToString[parameterList[[i]]["Name"]]<>", ",{i,1,Length[parameterList]}]],-2];
paramListAD=StringDrop[StringJoin[Table[
If[
KeyExistsQ[parameterList[[i]],"AD"]&&parameterList[[i]]["AD"]==True,
"const "<>CppTypeAD[computeType][parameterList[[i]]["Type"]]<>ArgType[parameterList[[i]]["Type"]]<>" "<>ToString[parameterList[[i]]["Name"]]<>", ",
"const "<>CppType[computeType][parameterList[[i]]["Type"]]<>ArgType[parameterList[[i]]["Type"]]<>" "<>ToString[parameterList[[i]]["Name"]]<>", "]
,{i,1,Length[parameterList]}
]],-2];

kernelFile=kernel["Name"]<>".kernel";
hhFile=kernel["Name"]<>".hh";
ccFile=kernel["Name"]<>".cc";
cuFile=kernel["Name"]<>".cu";

hh="#pragma once

template <typename REG> class "<>kernelName<>";
#include \"../def.hh\"

#include <memory>
#include <future>

namespace DiFfRG
{
  namespace Flows
  {
    class "<>className<>"
    {
    public:
      "<>className<>"(QuadratureProvider &quadrature_provider, std::array<uint, "<>ToString[kernel["Angles"]+2]<>"> grid_sizes, const "<>computeType<>" x_extent, const "<>computeType<>" x0_extent, const uint x0_summands, const JSONValue& json, const uint max_block_size = 256);
      "<>className<>"(const "<>className<>"& other);
      ~"<>className<>"();

      template<typename NT, typename... T>
      std::future<NT> request(T&&... t)
      {"<>
If[kernel["AD"],"
        static_assert(std::is_same_v<NT, "<>computeType<>"> || std::is_same_v<NT, autodiff::real>, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return request_CT(std::forward<T>(t)...);
        else if constexpr(std::is_same_v<NT, autodiff::real>)
          return request_AD(std::forward<T>(t)...);","
        static_assert(std::is_same_v<NT, "<>computeType<>"> , \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return request_CT(std::forward<T>(t)...);"
]<>"
      }

      template<typename NT, typename... T>
      NT get(T&&... t)
      {"<>
If[kernel["AD"],"
        static_assert(std::is_same_v<NT, "<>computeType<>"> || std::is_same_v<NT, autodiff::real>, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return get_CT(std::forward<T>(t)...);
        else if constexpr(std::is_same_v<NT, autodiff::real>)
          return get_AD(std::forward<T>(t)...);","
        static_assert(std::is_same_v<NT, "<>computeType<>">, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return get_CT(std::forward<T>(t)...);"
]<>"
      }

      void set_T(const "<>computeType<>" value);
      void set_x0_extent(const "<>computeType<>" value);

    private:
      std::future<"<>computeType<>"> request_CT(const "<>computeType<>" k, "<>paramList<>");
      "<>computeType<>" get_CT(const "<>computeType<>" k, "<>paramList<>");"<>
If[kernel["AD"],"
      std::future<autodiff::real> request_AD(const "<>computeType<>" k, "<>paramListAD<>");
      autodiff::real get_AD(const "<>computeType<>" k, "<>paramListAD<>");",
""]<>"

      QuadratureProvider& quadrature_provider;
      const std::array<uint, "<>ToString[kernel["Angles"]+2]<>"> grid_sizes;
      std::array<uint, "<>ToString[kernel["Angles"]+2]<>"> jac_grid_sizes;
      const "<>computeType<>" x_extent;
      const "<>computeType<>" x0_extent;
      const uint x0_summands;
      const "<>computeType<>" m_T;
      const "<>computeType<>" jacobian_quadrature_factor;
	  const JSONValue json;

      std::unique_ptr<"<>integrator<>"> integrator;"<>
If[kernel["AD"],"
      std::unique_ptr<"<>integratorAD<>"> integrator_AD;",
""]<>"
    };
  } // namespace Flows
} // namespace DiFfRG";

cc="#include \""<>cuFile<>"\"";
cu="#define FLOW_CODE

#include \""<>hhFile<>"\"
#include \""<>kernelFile<>"\"

namespace DiFfRG
{
  namespace Flows
  {
    "<>className<>"::"<>className<>"(QuadratureProvider &quadrature_provider, std::array<uint, "<>ToString[kernel["Angles"]+2]<>"> grid_sizes, const "<>computeType<>" x_extent, const "<>computeType<>" x0_extent, const uint x0_summands, const JSONValue& json)
        : quadrature_provider(quadrature_provider), grid_sizes(grid_sizes), x_extent(x_extent), 
          x0_extent(x0_extent), x0_summands(x0_summands), jacobian_quadrature_factor(json.get_double(\"/integration/jacobian_quadrature_factor\")), json(json)"<>"
    {
      integrator = std::make_unique<"<>integrator<>">(quadrature_provider, grid_sizes, x_extent, x0_extent, x0_summands, json);"<>
If[kernel["AD"],"
      for(uint i = 0; i < "<>ToString[kernel["Angles"]+2]<>"; ++i)
        jac_grid_sizes[i] = uint(jacobian_quadrature_factor * grid_sizes[i]);
      integrator_AD = std::make_unique<"<>integratorAD<>">(quadrature_provider, jac_grid_sizes, x_extent, x0_extent, x0_summands, json);",
""]<>"
    }

    "<>className<>"::"<>className<>"(const "<>className<>"& other)
        : quadrature_provider(other.quadrature_provider), grid_sizes(other.grid_sizes), jac_grid_sizes(other.jac_grid_sizes), x_extent(other.x_extent), 
          x0_extent(other.x0_extent), x0_summands(other.x0_summands), jacobian_quadrature_factor(other.jacobian_quadrature_factor), json(other.json),
          integrator(std::make_unique<"<>integrator<>">(other.quadrature_provider, other.grid_sizes, 
            other.x_extent, other.x0_extent, other.x0_summands, other.json))"<>
If[kernel["AD"],",
          integrator_AD(std::make_unique<"<>integratorAD<>">(other.quadrature_provider, other.jac_grid_sizes, 
            other.x_extent, other.x0_extent, other.x0_summands, other.json))",
""]<>"
    {
    }

    void  "<>className<>"::set_T(const "<>computeType<>" value)
    {
      integrator->set_T(value);"<>
      If[kernel["AD"],"
      integrator_AD->set_T(value);",""]<>"
    }
    void  "<>className<>"::set_x0_extent(const "<>computeType<>" value)
    {
      integrator->set_x0_extent(value);"<>
      If[kernel["AD"],"
      integrator_AD->set_x0_extent(value);",""]<>"
    }

    "<>className<>"::~"<>className<>"() = default;

    std::future<"<>computeType<>"> "<>className<>"::request_CT(const "<>computeType<>" k, "<>paramList<>")
    {
      return integrator->request(k, "<>argList<>");
    }

    "<>computeType<>" "<>className<>"::get_CT(const "<>computeType<>" k, "<>paramList<>")
    {
      return integrator->get(k, "<>argList<>");
    }"<>
If[kernel["AD"],"

    std::future<autodiff::real> "<>className<>"::request_AD(const "<>computeType<>" k, const "<>paramListAD<>")
    {
      return integrator_AD->request(k, "<>argList<>");
    }

    autodiff::real "<>className<>"::get_AD(const "<>computeType<>" k, "<>paramListAD<>")
    {
      return integrator_AD->get(k, "<>argList<>");
    }",
""]<>"
  } // namespace Flows
} // namespace DiFfRG";

ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>hhFile,hh];
ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>ccFile,cc];
ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>cuFile,cu];
];


(* ::Input::Initialization:: *)
MakeKernelIntegratorFiniteTq0[kernel_Association,parameterList_List]:=
Module[{computeType,kernelName,className,integrator,integratorAD,argList,paramList,paramListAD,kernelFile,hhFile,ccFile,cuFile,hh,cc,cu},
If[Not@IsValidKernelSpec[kernel],Print["DiFfRG::CodeTools::MakeKernelIntegratorFiniteTq0: Invalid kernel!"];Abort[]];
If[Not@IsValidParameterList[parameterList],Print["DiFfRG::CodeTools::MakeKernelIntegratorFiniteTq0: Invalid parameter List!"];Abort[]];

computeType=kernel["ctype"];

kernelName=kernel["Name"]<>"_kernel";
className=kernel["Name"]<>"_integrator"; 

If[kernel["Angles"]==0,
integrator="DiFfRG::IntegratorFiniteTq0"<>DeviceChoice[kernel["Device"]]<>"<"<>ToString[kernel["d"]]<>", "<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::IntegratorFiniteTq0"<>DeviceChoice[kernel["Device"]]<>"<"<>ToString[kernel["d"]]<>", autodiff::real, "<>kernelName<>"<__REGULATOR__>>" 
];
If[kernel["Angles"]==1,
integrator="DiFfRG::IntegratorAngleFiniteTq0"<>DeviceChoice[kernel["Device"]]<>"<"<>ToString[kernel["d"]]<>", "<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::IntegratorAngleFiniteTq0"<>DeviceChoice[kernel["Device"]]<>"<"<>ToString[kernel["d"]]<>", autodiff::real, "<>kernelName<>"<__REGULATOR__>>" 
];
If[kernel["Angles"]==2,
If[kernel["d"]!=4,Print["Inconsistent dimensions!"];Abort[]];
integrator="DiFfRG::Integrator4DFiniteTq0"<>DeviceChoice[kernel["Device"]]<>"<"<>computeType<>", "<>kernelName<>"<__REGULATOR__>>" ;
integratorAD="DiFfRG::Integrator4DFiniteTq0"<>DeviceChoice[kernel["Device"]]<>"<autodiff::real, "<>kernelName<>"<__REGULATOR__>>" 
];

argList=StringDrop[StringJoin[Table[""<>ToString[parameterList[[i]]["Name"]]<>", ",{i,1,Length[parameterList]}]],-2];
paramList=StringDrop[StringJoin[Table["const "<>CppType[computeType][parameterList[[i]]["Type"]]<>ArgType[parameterList[[i]]["Type"]]<>" "<>ToString[parameterList[[i]]["Name"]]<>", ",{i,1,Length[parameterList]}]],-2];
paramListAD=StringDrop[StringJoin[Table[
If[
KeyExistsQ[parameterList[[i]],"AD"]&&parameterList[[i]]["AD"]==True,
"const "<>CppTypeAD[computeType][parameterList[[i]]["Type"]]<>ArgType[parameterList[[i]]["Type"]]<>" "<>ToString[parameterList[[i]]["Name"]]<>", ",
"const "<>CppType[computeType][parameterList[[i]]["Type"]]<>ArgType[parameterList[[i]]["Type"]]<>" "<>ToString[parameterList[[i]]["Name"]]<>", "]
,{i,1,Length[parameterList]}
]],-2];

kernelFile=kernel["Name"]<>".kernel";
hhFile=kernel["Name"]<>".hh";
ccFile=kernel["Name"]<>".cc";
cuFile=kernel["Name"]<>".cu";

hh="#pragma once

template <typename REG> class "<>kernelName<>";
#include \"../def.hh\"

#include <memory>
#include <future>

namespace DiFfRG
{
  namespace Flows
  {
    class "<>className<>"
    {
    public:
      "<>className<>"(QuadratureProvider &quadrature_provider, std::array<uint, "<>ToString[kernel["Angles"]+1]<>"> grid_sizes, const "<>computeType<>" x_extent, const JSONValue& json);
      "<>className<>"(const "<>className<>"& other);
      ~"<>className<>"();

      template<typename NT, typename... T>
      std::future<NT> request(T&&... t)
      {"<>
If[kernel["AD"],"
        static_assert(std::is_same_v<NT, "<>computeType<>"> || std::is_same_v<NT, autodiff::real>, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return request_CT(std::forward<T>(t)...);
        else if constexpr(std::is_same_v<NT, autodiff::real>)
          return request_AD(std::forward<T>(t)...);",
"
        static_assert(std::is_same_v<NT, "<>computeType<>">, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return request_CT(std::forward<T>(t)...);"]<>"
      }

      template<typename NT, typename... T>
      NT get(T&&... t)
      {"<>
If[kernel["AD"],"
        static_assert(std::is_same_v<NT, "<>computeType<>"> || std::is_same_v<NT, autodiff::real>, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return get_CT(std::forward<T>(t)...);
        else if constexpr(std::is_same_v<NT, autodiff::real>)
          return get_AD(std::forward<T>(t)...);",
"
        static_assert(std::is_same_v<NT, "<>computeType<>">, \"Unknown type requested of "<>className<>"::request\");
        if constexpr(std::is_same_v<NT, "<>computeType<>">)
          return get_CT(std::forward<T>(t)...);"]<>"
      }

      void set_T(const "<>computeType<>" T, const "<>computeType<>" E = 0);

    private:
      std::future<"<>computeType<>"> request_CT(const "<>computeType<>" k, "<>paramList<>");
      "<>computeType<>" get_CT(const "<>computeType<>" k, "<>paramList<>");"<>
If[kernel["AD"],"
      std::future<autodiff::real> request_AD(const "<>computeType<>" k, "<>paramListAD<>");
      autodiff::real get_AD(const "<>computeType<>" k, "<>paramListAD<>");",
""]<>"

      QuadratureProvider& quadrature_provider;
      const std::array<uint, "<>ToString[kernel["Angles"]+1]<>"> grid_sizes;
      std::array<uint, "<>ToString[kernel["Angles"]+1]<>"> jac_grid_sizes;
      const "<>computeType<>" x_extent;
      const "<>computeType<>" jacobian_quadrature_factor;
      const JSONValue json;

      std::unique_ptr<"<>integrator<>"> integrator;"<>
If[kernel["AD"],"
      std::unique_ptr<"<>integratorAD<>"> integrator_AD;",
""]<>"
    };
  } // namespace Flows
} // namespace DiFfRG";

cc="#include \""<>cuFile<>"\"";
cu="#define FLOW_CODE

#include \""<>hhFile<>"\"
#include \""<>kernelFile<>"\"

namespace DiFfRG
{
  namespace Flows
  {
    "<>className<>"::"<>className<>"(QuadratureProvider &quadrature_provider, std::array<uint, "<>ToString[kernel["Angles"]+1]<>"> grid_sizes, const "<>computeType<>" x_extent, const JSONValue& json)
        : quadrature_provider(quadrature_provider), grid_sizes(grid_sizes), x_extent(x_extent), 
          jacobian_quadrature_factor(json.get_double(\"/integration/jacobian_quadrature_factor\")), json(json)"<>"
    {
      integrator = std::make_unique<"<>integrator<>">(quadrature_provider, grid_sizes, x_extent, json);"<>
If[kernel["AD"],"
      for(uint i = 0; i < "<>ToString[kernel["Angles"]+1]<>"; ++i)
        jac_grid_sizes[i] = uint(jacobian_quadrature_factor * grid_sizes[i]);
      integrator_AD = std::make_unique<"<>integratorAD<>">(quadrature_provider, jac_grid_sizes, x_extent, json);",""]<>"
    }

    "<>className<>"::"<>className<>"(const "<>className<>"& other)
        : quadrature_provider(other.quadrature_provider), grid_sizes(other.grid_sizes), jac_grid_sizes(other.jac_grid_sizes), x_extent(other.x_extent), 
          jacobian_quadrature_factor(other.jacobian_quadrature_factor), json(other.json),
          integrator(std::make_unique<"<>integrator<>">(other.quadrature_provider, other.grid_sizes, 
            other.x_extent, other.json))"<>
If[kernel["AD"],",
          integrator_AD(std::make_unique<"<>integratorAD<>">(other.quadrature_provider, other.jac_grid_sizes, 
            other.x_extent, other.json))",""]<>"
    {
    }

    "<>className<>"::~"<>className<>"() = default;

    void  "<>className<>"::set_T(const "<>computeType<>" T, const "<>computeType<>" E)
    {
      integrator->set_T(T, E);"<>
      If[kernel["AD"],"
      integrator_AD->set_T(T, E);",""]<>"
    }

    std::future<"<>computeType<>"> "<>className<>"::request_CT(const "<>computeType<>" k, "<>paramList<>")
    {
      return integrator->request(k, "<>argList<>");
    }

    "<>computeType<>" "<>className<>"::get_CT(const "<>computeType<>" k, "<>paramList<>")
    {
      return integrator->get(k, "<>argList<>");
    }
"<>If[kernel["AD"],"
    std::future<autodiff::real> "<>className<>"::request_AD(const "<>computeType<>" k, "<>paramListAD<>")
    {
      return integrator_AD->request(k, "<>argList<>");
    }

    autodiff::real "<>className<>"::get_AD(const "<>computeType<>" k, "<>paramListAD<>")
    {
      return integrator_AD->get(k, "<>argList<>");
    }",""]<>"
  } // namespace Flows
} // namespace DiFfRG";

ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>hhFile,hh];
ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>ccFile,cc];
ExportCode[flowDir<>""<>kernel["Path"]<>"/"<>cuFile,cu];
];


(* ::Input::Initialization:: *)
MakeKernelFiniteTx0[kernel_Association, parameterList_List,integrandFlow_, constantFlow_:0., integrandDefinitions_String:"", constantDefinitions_String:""] := Module[{},
If[Not@IsValidKernelSpecList[kernels],Print["DiFfRG::CodeTools::MakeKernelFiniteTx0: Invalid kernels list!"];Abort[]];
If[Not@IsValidParameterList[parameterList],Print["DiFfRG::CodeTools::MakeKernelFiniteTx0: Invalid parameter List!"];Abort[]];

MakeKernelClassFiniteT[kernel,parameterList,integrandFlow,constantFlow,integrandDefinitions,constantDefinitions];
MakeKernelIntegratorFiniteTx0[kernel,parameterList];
];


(* ::Input::Initialization:: *)
MakeKernelFiniteTq0[kernel_Association, parameterList_List,integrandFlow_, constantFlow_:0., integrandDefinitions_String:"", constantDefinitions_String:""] := Module[{},
If[Not@IsValidKernelSpecList[kernels],Print["DiFfRG::CodeTools::MakeKernelFiniteTq0: Invalid kernels list!"];Abort[]];
If[Not@IsValidParameterList[parameterList],Print["DiFfRG::CodeTools::MakeKernelFiniteTq0: Invalid parameter List!"];Abort[]];

MakeKernelClassFiniteT[kernel,parameterList,integrandFlow,constantFlow,integrandDefinitions,constantDefinitions];
MakeKernelIntegratorFiniteTq0[kernel,parameterList];
];


QuadTypes={"QMC","Constant","Quadrature","CartesianQuadrature"}

MakeKernel[kernel_Association, parameterList_List,integrandFlow_, constantFlow_:0., integrandDefinitions_String:"", constantDefinitions_String:""] := Module[{},
If[Not@IsValidKernelSpecList[kernels],Print["DiFfRG::CodeTools::MakeKernel: Invalid kernels list!"];Abort[]];
If[Not@IsValidParameterList[parameterList],Print["DiFfRG::CodeTools::MakeKernel: Invalid parameter List!"];Abort[]];

If[MemberQ[QuadTypes,kernel["Type"]],
MakeKernelClass[kernel,parameterList,integrandFlow,constantFlow,integrandDefinitions,constantDefinitions];
MakeKernelIntegrator[kernel,parameterList];
Return[];
];

If[kernel["Type"]=="Quadraturex0",
MakeKernelFiniteTx0[kernel, parameterList,integrandFlow, constantFlow, integrandDefinitions, constantDefinitions];
Return[];
];

If[kernel["Type"]=="Quadratureq0",
MakeKernelFiniteTq0[kernel, parameterList,integrandFlow, constantFlow, integrandDefinitions, constantDefinitions];
Return[];
];

Print["Error: Unknown integrator type \""<>kernel["Type"]<>"\"!"];
Abort[];
];


Protect["DiFfRG`CodeTools`*"];


End[];


EndPackage[];
