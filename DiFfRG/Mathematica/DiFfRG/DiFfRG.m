(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



Print["Mathematica package \!\(\*
StyleBox[\"DiFfRG\",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\" \",\nFontWeight->\"Bold\"]\)loaded
\!\(\*
StyleBox[\"Authors\",\nFontWeight->\"Bold\"]\): Franz Richard Sattler
\!\(\*
StyleBox[\"Version\",\nFontWeight->\"Bold\"]\): 1.0
\!\(\*
StyleBox[\"Year\",\nFontWeight->\"Bold\"]\): 2024
"]


QMeSInstalled[]:=Module[{QMeSDirectory},
QMeSDirectory=SelectFirst[
Join[
{
FileNameJoin[{$UserBaseDirectory,"Applications","QMeSderivation"}],
FileNameJoin[{$BaseDirectory,"Applications","QMeSderivation"}],
FileNameJoin[{$InstallationDirectory,"AddOns","Applications","QMeSderivation"}],
FileNameJoin[{$InstallationDirectory,"AddOns","Packages","QMeSderivation"}],
FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","QMeSderivation"}]
},
Select[$Path,StringContainsQ[#,"QMeSderivation"]&]
],
DirectoryQ[#]&
]<>"/"//Quiet;
If[Head[QMeSDirectory]=!=String,Return[False]];
Return[True];
];

If[Not@QMeSInstalled[],
If[ChoiceDialog["QMeS does not seem to be installed. Do you want to install it?",WindowTitle->"Install QMeS",WindowSize->{Medium,All}],
Import["https://raw.githubusercontent.com/QMeS-toolbox/QMeS-Derivation/main/QMeSInstaller.m"],
Print["The \!\(\*
StyleBox[\"DiFfRG\",\nFontWeight->\"Bold\"]\) package requires \!\(\*
StyleBox[\"QMeS\",\nFontWeight->\"Bold\"]\) to run."];Abort[];
];
];


TensorBasesInstalled[]:=Module[{TensorBasesDirectory},
TensorBasesDirectory=SelectFirst[
Join[
{
FileNameJoin[{$UserBaseDirectory,"Applications","TensorBases"}],
FileNameJoin[{$BaseDirectory,"Applications","TensorBases"}],
FileNameJoin[{$InstallationDirectory,"AddOns","Applications","TensorBases"}],
FileNameJoin[{$InstallationDirectory,"AddOns","Packages","TensorBases"}],
FileNameJoin[{$InstallationDirectory,"AddOns","ExtraPackages","TensorBases"}]
},
Select[$Path,StringContainsQ[#,"TensorBases"]&]
],
DirectoryQ[#]&
]<>"/"//Quiet;
If[Head[TensorBasesDirectory]=!=String,Return[False]];
Return[True];
];

If[Not@TensorBasesInstalled[],
If[ChoiceDialog["TensorBases does not seem to be installed. Do you want to install it?",WindowTitle->"Install TensorBases",WindowSize->{Medium,All}],
Import["https://raw.githubusercontent.com/satfra/TensorBases/main/TensorBasesInstaller.m"],
Print["The \!\(\*
StyleBox[\"DiFfRG\",\nFontWeight->\"Bold\"]\) package requires \!\(\*
StyleBox[\"TensorBases\",\nFontWeight->\"Bold\"]\) to run."];Abort[];
];
];


Print["\!\(\*
StyleBox[\"Loading\",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"external\",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"packages\",\nFontSize->10,\nFontSlant->\"Italic\"]\)"];
Get["FunKit`"]
Print["\!\(\*
StyleBox[\"FunKit\",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"loaded\",\nFontSize->10,\nFontSlant->\"Italic\"]\)"];
Get["QMeSderivation`"]
Print["\!\(\*
StyleBox[\"QMeS\",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"loaded\",\nFontSize->10,\nFontSlant->\"Italic\"]\)"];
Get["TensorBases`"]
Print["\!\(\*
StyleBox[\"TensorBases\",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"loaded\",\nFontSize->10,\nFontSlant->\"Italic\"]\)"];
Get["DiFfRG`CodeTools`"];
Print["\!\(\*
StyleBox[\"CodeTools\",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSize->10,\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"loaded\",\nFontSize->10,\nFontSlant->\"Italic\"]\)"];


(* ::Input::Initialization:: *)
(*BeginPackage["DiFfRG`"];*)
Unprotect["DiFfRG`*"];
Unprotect["DiFfRG`Private`*"];
ClearAll["DiFfRG`*"];
ClearAll["DiFfRG`Private`*"];


If[Head[$DistributedContexts]=!=List,$DistributedContexts={}];
$DistributedContexts=$DistributedContexts\[Union]{$Context,"DiFfRG`","FormTracer`","QMeSderivation`","QMeSderivation`Tools`","QMeSderivation`Private`","TensorBases`","TensorBases`Private`"}


GetDirectory::usage="GetDirectory[]
Returns the directory in which either the package file or notebook is located.";

AutoExport::usage="AutoExport[]
Turns on automatic export of the current notebook to a .m file.";

AutoSaveRestore::usage="AutoSaveRestore[fileName_String,expr_]
Evaluates expr if the file fileName does not yet exist and saves it to fileName as a .m file. If fileName exists, it does not evaluate expr, but simply loads the contents.";

ClearTraceCache::usage="ClearTraceCache[]
Removes the folder TraceBuffer.

ClearTraceCache[name_String]
Removes the folder TraceBuffer/name/";


MatsubaraSum::usage = "MatsubaraSum[expr_,p0_Symbol,T_]
Sums the expression expr over p0, with p0 = 2\[Pi]T*n, where n\[Element]\[CapitalZeta].";


ResolveChargeConjugation::usage="ResolveChargeConjugation[expr_]
Resolves all occurences of ChargeConj[i,j] by using the effect of these in Weyl representation.";


UseSU3GellMannTrace::usage="SU3GellMannTrace[value_?BooleanQ,groupName_String:\"color\"]
Traces the generators of the fundamental representation in the given group as SU(3) Gell-Mann matrices explicitly.";


PreTrace::usage="PreTrace[expr_]
Resolve charge conjugation and perform possibly the explicit color trace."


FormMomentumExpansion::usage="FormMomentumExpansion[momenta___]"
FiniteTFormMomentumExpansion[momenta__]


MakeP0FormRule::usage="MakeP0FormRule[q_,{momenta__},{projections__}]"
GetFTSynonym::usage="GetFTSynonym[symbol_]"
MakeSPFormRule::usage="MakeSPFormRule[q_,p_,momenta__]"
MakeSPFormRule::usage="MakeSPFormRule[q_,p_,momenta__]"
MakeSPFiniteTFormRule::usage="MakeSPFiniteTFormRule[q_,p_,momenta__]"
ExtendedFormTrace::usage="ExtendedFormTrace[expr_,disentangle:_?BooleanQ:True,preRepRules_List:{},postRepRules_List:{}]"

SeparateScalarProductsFiniteT::usage="SeparateScalarProductsFiniteT[expr_]"
ExpandScalarProductsFiniteT::usage="ExpandScalarProductsFiniteT[expr_]"
ExpandScalarProducts::usage="ExpandScalarProducts[expr_]"
SimplifyAllMomenta::usage="SimplifyAllMomenta[q_,expr_]"
ProjectToSymmetricPoint::usage="ProjectToSymmetricPoint[expr_,q_Symbol,p_Symbol,momenta___Symbol]"
ProjectToSymmetricPointFiniteT::usage="ProjectToSymmetricPointFiniteT[expr_,q_Symbol,p_Symbol,momenta___Symbol]"

QuickSimplify::usage="QuickSimplify[expr_]"
SetStandardQuickSimplify::usage="SetStandardQuickSimplify[sim_]"
SetStandardSimplify::usage="SetStandardSimplify[sim_]"

SetDisentangle::usage="SetDisentangle[ex_]"
SumDiagrams::usage="SumDiagrams[nKernels_Integer,postfix_String,number_Integer:0,operation_:$StandardQuickSimplify,saveName_String:\"sum\"]";
TraceDiagrams::usage="TraceDiagrams[simpFunc_,nKernels_Integer,postfix_String,ex_,preRepRules_List:{},postRepRules_List:{}]"


(*Begin["`Private`"]*)


Unprotect[GetDirectory];
GetDirectory[]:=If[$Notebooks,NotebookDirectory[],Directory[]]<>"/";


(* ::Input::Initialization:: *)
AutoExport[Switch:_?BooleanQ:True]:=If[Switch,
SetOptions[EvaluationNotebook[],{
AutoGeneratedPackage->Automatic,
InitializationCellEvaluation->False,
InitializationCellWarning->False,StyleDefinitions->Notebook[
{Cell[StyleData[StyleDefinitions->"Default.nb"]],Cell[StyleData["Input"],InitializationCell->True]},Visible->False,StyleDefinitions->"PrivateStylesheetFormatting.nb"
]}],
SetOptions[EvaluationNotebook[],{
AutoGeneratedPackage->False
}]
];


AutoSaveRestore[fileName_String,expr_]:=Module[{ret},
If[FileExistsQ[fileName<>".m"],
ret=Import[fileName<>".m"];
Print["Imported existing file \""<>fileName<>".m"<>"\"..."];
,
ret=ReleaseHold[expr];
Export[fileName<>".m",ret];
Print["Saved to file \""<>fileName<>".m"<>"\"..."];
];
ret
];
SetAttributes[AutoSaveRestore,HoldRest]
AutoSaveRestoreQuiet[fileName_String,expr_]:=Module[{ret},
If[FileExistsQ[fileName<>".m"],
ret=Import[fileName<>".m"];
,
ret=ReleaseHold[expr];
Export[fileName<>".m",ret];
];
ret
];
SetAttributes[AutoSaveRestoreQuiet,HoldRest]


ClearTraceCache[name_String:""]:=Module[{},
If[name=="",
DeleteDirectory[GetDirectory[]~~"TraceBuffer/",DeleteContents->True]//Quiet;,
DeleteDirectory[GetDirectory[]~~"TraceBuffer/"~~name~~"/",DeleteContents->True]//Quiet;
];
];


MatsubaraSum[expr_,p0_Symbol,T_]:=Module[{denom,poles,residues,n,r,SumB},
If[Head[expr]==Plus,Return[Total[Flatten[Map[MatsubaraSum[#,p0,T]&,List@@expr],1]]]];denom = Denominator[expr]//Collect[#,p0]&;
poles = p0/.{ToRules[Reduce[Reduce[denom==0,p0]//FullSimplify,p0]]};
poles = Assuming[T>0&&_Symbol\[Element]Reals,poles//FullSimplify];

residues={};For[n=1,n<=Length[poles],n++,
r=Simplify[Residue[expr Coth[(I p0)/(2T)],{p0,poles[[n]]}]];
AppendTo[residues,r];];
SumB=1/(2I) TrigReduce[residues];
Total[SumB]
];


InsertOutputNaming[expr_]:=Module[
{
groups,
outputRulesLorentzTensors,outputRulesGroupTensors,outputRules,
privateOutputRulesLorentzTensors,privateOutputRulesGroupTensors,privateOutputRules,
otherRules
},

outputRulesLorentzTensors=Normal[FormTracer`Private`lorentzTensorReplacementRulesOutput]/.{(a_[c___]:>b_):>(Symbol["TB"~~StringSplit[ToString[a],"FTx"][[-1]]][c]:>b)};
outputRulesGroupTensors=Normal[FormTracer`Private`groupTensorReplacementRulesOutput]/.{(a_[c___]:>b_):>(Symbol["TB"~~StringSplit[ToString[a],"FTx"][[-1]]][c]:>b)};
outputRules=Join[outputRulesLorentzTensors,outputRulesGroupTensors];

Return[
Evaluate[expr//.outputRules]
];
];


InsertInputNaming[expr_]:=Module[
{
inputRulesLorentzTensors,inputRulesGroupTensors
},

inputRulesLorentzTensors=Select[Normal[FormTracer`Private`lorentzTensorReplacementRulesInput],MatchQ[_[__]:>_[__]]]/.{
(a_[d__]:>b_[c__]):>(a[d]->Symbol["TB"~~StringSplit[ToString[b],"FTx"][[-1]]][c])
};
inputRulesGroupTensors=Select[Normal[FormTracer`Private`groupTensorReplacementRulesInput],MatchQ[_[__]:>_[__]]]/.{
(a_[d__]:>b_[c__]):>(a[d]->Symbol["TB"~~StringSplit[ToString[b],"FTx"][[-1]]][c])
};

Return[
expr//.inputRulesLorentzTensors//.inputRulesGroupTensors/.a_Symbol:>Symbol["Global`"~~SymbolName[a]]
];
];


ImplodeTerms[expr_]:=expr;
ImplodeTerms[expr_List]:=Module[{ret},
If[Head[expr[[1]]]===List,
Plus@@Map[ImplodeTerms,expr],
Times@@Map[ImplodeTerms,expr]
]
];
CollapseTerms[expr_]:=expr;
CollapseTerms[expr_List]:=Total[Map[#[[1]]*CollapseTerms[#[[2]]]&,expr]];

FixChargeConj[expr_]:=
Module[{ret,restoreIdx,rule,chargeRules},
Block[{Print},DisentangleLorentzStructures[False]];
ret=expr;
restoreIdx={};
ret=ret//.ChargeConj[a_,b_]:>Module[{},restoreIdx=Append[restoreIdx,{a,b}];InsertOutputNaming[TBdeltaDirac[a,b]]];
rule=Map[InsertOutputNaming[TBdeltaDirac[#[[1]],#[[2]]]]:>ChargeConj[#[[1]],#[[2]]]&,restoreIdx];
ret=FormTracer`ExpandTerms[ret]//.rule//Expand//InsertOutputNaming;

chargeRules={
TBgamma[mu_,a_,c_]ChargeConj[a_,b_]:>-ChargeConj[c,a]TBgamma[mu,a,b],
TBgamma[mu_,a_,b_]ChargeConj[b_,c_]:>-ChargeConj[a,b]TBgamma[mu,c,b],

TBgamma5[a_,c_]ChargeConj[a_,b_]:>ChargeConj[c,a]TBgamma5[a,b],
TBgamma5[a_,b_]ChargeConj[b_,c_]:>ChargeConj[a,b]TBgamma5[c,b],

TBdeltaDirac[a_,b_]ChargeConj[b_,c_]:>ChargeConj[a,c],
TBdeltaDirac[a_,b_]ChargeConj[c_,b_]:>ChargeConj[c,a],
TBdeltaDirac[b_,a_]ChargeConj[b_,c_]:>ChargeConj[a,c],

ChargeConj[a_,b_]ChargeConj[a_,c_]:>deltaDirac[b,c],
ChargeConj[a_,b_]ChargeConj[c_,b_]:>deltaDirac[a,c],
ChargeConj[a_,b_]ChargeConj[b_,c_]:>-deltaDirac[a,c]
}//InsertOutputNaming;
ret=ret//.chargeRules;

(*This is chiral Weyl representation-specific.*)
ret=ret//.{ChargeConj[a_,b_]:>Module[{dint},TBgamma[2,a,dint]TBgamma[0,dint,b]]};
Return[ImplodeTerms[ret]//InsertOutputNaming];
];

ResolveChargeConjugation[expr_]:=Module[{},
If[
MemberQ[expr,ChargeConj[__],Infinity],
expr//FixChargeConj
,
expr
]
];


integrateDeltas[expr_]:=Module[{list1,list2,conv=InsertOutputNaming},
list1={
FormTracer`Private`FTxdeltaLorentz[a_,b_]FormTracer`Private`FTxdeltaLorentz[a_,c_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaLorentz[b,c],
conv@TBdeltaLorentz[a_,b_]conv@TBdeltaLorentz[a_,c_]/;Not[NumberQ[a]]:>conv@TBdeltaLorentz[b,c],

FormTracer`Private`FTxdeltaLorentz[a_,b_]FormTracer`Private`FTxdeltaLorentz[c_,a_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaLorentz[b,c],
conv@TBdeltaLorentz[a_,b_]conv@TBdeltaLorentz[c_,a_]/;Not[NumberQ[a]]:>conv@TBdeltaLorentz[b,c],

FormTracer`Private`FTxdeltaLorentz[b_,a_]FormTracer`Private`FTxdeltaLorentz[a_,c_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaLorentz[b,c],
conv@TBdeltaLorentz[b_,a_]conv@TBdeltaLorentz[a_,c_]/;Not[NumberQ[a]]:>conv@TBdeltaLorentz[b,c],

FormTracer`Private`FTxdeltaLorentz[b_,a_]FormTracer`Private`FTxdeltaLorentz[c_,a_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaLorentz[b,c],
conv@TBdeltaLorentz[b_,a_]conv@TBdeltaLorentz[c_,a_]/;Not[NumberQ[a]]:>conv@TBdeltaLorentz[b,c],

FormTracer`Private`FTxdeltaLorentz[a_,a_]:>If[NumberQ[a],1,4],
conv@TBdeltaLorentz[a_,a_]:>If[NumberQ[a],1,4],

conv@TBvec[p_,a_]conv@TBdeltaLorentz[a_,b_]conv@TBvec[q_,b_]:>conv@TBsp[p,q] ,
conv@TBvec[p_,a_]conv@TBdeltaLorentz[b_,a_]conv@TBvec[q_,b_]:>conv@TBsp[p,q] ,
conv@TBvecs[p_,a_]conv@TBdeltaLorentz[a_,b_]conv@TBvecs[q_,b_]:>conv@TBsps[p,q] ,
conv@TBvecs[p_,a_]conv@TBdeltaLorentz[b_,a_]conv@TBvecs[q_,b_]:>conv@TBsps[p,q] 
};
list2={
FormTracer`Private`FTxdeltaDirac[a_,b_]FormTracer`Private`FTxdeltaDirac[a_,c_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaDirac[b,c],
conv@TBdeltaDirac[a_,b_]conv@TBdeltaDirac[a_,c_]/;Not[NumberQ[a]]:>conv@TBdeltaDirac[b,c],

FormTracer`Private`FTxdeltaDirac[a_,b_]FormTracer`Private`FTxdeltaDirac[c_,a_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaDirac[b,c],
conv@TBdeltaDirac[a_,b_]conv@TBdeltaDirac[c_,a_]/;Not[NumberQ[a]]:>conv@TBdeltaDirac[c,b],

FormTracer`Private`FTxdeltaDirac[b_,a_]FormTracer`Private`FTxdeltaDirac[a_,c_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaDirac[b,c],
conv@TBdeltaDirac[b_,a_]conv@TBdeltaDirac[a_,c_]/;Not[NumberQ[a]]:>conv@TBdeltaDirac[b,c],

FormTracer`Private`FTxdeltaDirac[b_,a_]FormTracer`Private`FTxdeltaDirac[c_,a_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaDirac[b,c],
conv@TBdeltaDirac[b_,a_]conv@TBdeltaDirac[c_,a_]/;Not[NumberQ[a]]:>conv@TBdeltaDirac[b,c],

FormTracer`Private`FTxdeltaDirac[a_,a_]:>If[NumberQ[a],1,4],
conv@TBdeltaDirac[a_,a_]:>If[NumberQ[a],1,4],

conv@TBdeltaDirac[b_,a_]conv@TBgamma[mu_,c_,a_]/;Not[NumberQ[a]]:>conv@TBgamma[mu,c,b],
conv@TBdeltaDirac[a_,b_]conv@TBgamma[mu_,c_,a_]/;Not[NumberQ[a]]:>conv@TBgamma[mu,c,b],
conv@TBdeltaDirac[b_,a_]conv@TBgamma[mu_,a_,c_]/;Not[NumberQ[a]]:>conv@TBgamma[mu,b,c],
conv@TBdeltaDirac[a_,b_]conv@TBgamma[mu_,a_,c_]/;Not[NumberQ[a]]:>conv@TBgamma[mu,b,c],

conv@TBdeltaDirac[b_,a_]conv@TBgamma5[c_,a_]/;Not[NumberQ[a]]:>conv@TBgamma5[c,b],
conv@TBdeltaDirac[a_,b_]conv@TBgamma5[c_,a_]/;Not[NumberQ[a]]:>conv@TBgamma5[c,b],
conv@TBdeltaDirac[b_,a_]conv@TBgamma5[a_,c_]/;Not[NumberQ[a]]:>conv@TBgamma5[b,c],
conv@TBdeltaDirac[a_,b_]conv@TBgamma5[a_,c_]/;Not[NumberQ[a]]:>conv@TBgamma5[b,c]
};
Return[expr//.list1//.list2]
];


$SU3GellMannGroupName=color;
$UseSU3GellMannTrace=False;
UseSU3GellMannTrace[value_?BooleanQ,groupName_Symbol:color]:=Module[{},
If[value,
DefineFormTracerGroup[{groupName,SUNfund,Nc}];
$SU3GellMannGroupName=groupName;
];
$UseSU3GellMannTrace=value;
]


(* ::Input::Initialization:: *)
integrateGroupDeltas[expr_,dimAdj_,dimFund_]:=Module[{tmpFundRule,tmpAdjRule},
FixedPoint[#/.(

tmpFundRule=FirstCase[#,FormTracer`Private`FTxdeltaFund[$SU3GellMannGroupName,a_,b_]/;Not[NumberQ[a]]:>{a,b}];
tmpAdjRule=FirstCase[#,FormTracer`Private`FTxdeltaAdj[$SU3GellMannGroupName,a_,b_]/;Not[NumberQ[a]]:>{a,b}];

Join[
If[tmpFundRule===Missing["NotFound"],{},
{FormTracer`Private`FTxdeltaFund[$SU3GellMannGroupName,tmpFundRule[[1]],tmpFundRule[[2]]]:>1,tmpFundRule[[1]]->tmpFundRule[[2]]}
],
If[tmpAdjRule===Missing["NotFound"],{},
{FormTracer`Private`FTxdeltaAdj[$SU3GellMannGroupName,tmpAdjRule[[1]],tmpAdjRule[[2]]]:>1,tmpAdjRule[[1]]->tmpAdjRule[[2]]}
]
]

)/.(

tmpFundRule=FirstCase[#,FormTracer`Private`FTxdeltaFund[$SU3GellMannGroupName,a_,b_]/;Not[NumberQ[b]]:>{b,a}];
tmpAdjRule=FirstCase[#,FormTracer`Private`FTxdeltaAdj[$SU3GellMannGroupName,a_,b_]/;Not[NumberQ[b]]:>{b,a}];

Join[
If[tmpFundRule===Missing["NotFound"],{},
{FormTracer`Private`FTxdeltaFund[$SU3GellMannGroupName,tmpFundRule[[1]],tmpFundRule[[2]]]:>1,tmpFundRule[[1]]->tmpFundRule[[2]]}
],
If[tmpAdjRule===Missing["NotFound"],{},
{FormTracer`Private`FTxdeltaAdj[$SU3GellMannGroupName,tmpAdjRule[[1]],tmpAdjRule[[2]]]:>1,tmpAdjRule[[1]]->tmpAdjRule[[2]]}
]
]

)/.{
FormTracer`Private`FTxdeltaAdj[$SU3GellMannGroupName,a_,a_]:>If[NumberQ[a],1,dimAdj],FormTracer`Private`FTxdeltaFund[$SU3GellMannGroupName,a_,a_]:>If[NumberQ[a],1,dimFund]
}&,
expr]
];


SU3GellMannTrace[expr_]:=Module[{dimAdj=8,dimFund=3,fg,f,T,deltasIntegrated,preFactorSeparated,replacedTensors,adjIndices,fundIndices,InsertTensors},

deltasIntegrated=integrateGroupDeltas[expr,dimAdj,dimFund];

fg[{x_Integer,y_Integer,z_Integer}]:=0;
fg[{1,2,3}]=1;
fg[{1,4,7}]=1/2;
fg[{1,5,6}]=-1/2;
fg[{2,4,6}]=1/2;
fg[{2,5,7}]=1/2;
fg[{3,4,5}]=1/2;
fg[{3,6,7}]=-1/2;
fg[{4,5,8}]=Sqrt[3]/2;
fg[{6,7,8}]=Sqrt[3]/2;
f[list_List/;Length[list]==3&&IntegerQ[list[[1]]]&&IntegerQ[list[[2]]]&&IntegerQ[list[[3]]]]:=Signature[list]*fg[Sort[list]];

T[a_Integer,i_Integer,j_Integer]:=0;
T[0,_,_]:=(Print["ERROR: U3 is not supported as of now (but could be if necessary)!"];Abort[]);
(*T[0,1,1]=T[0,2,2]=T[0,3,3]=1/Sqrt[6];*)
T[1,1,2]=T[1,2,1]=1/2;
T[2,1,2]=-I/2;
T[2,2,1]=-T[2,1,2];
T[3,1,1]=1/2;
T[3,2,2]=-T[3,1,1];
T[4,1,3]=T[4,3,1]=1/2;
T[5,1,3]=-I/2;
T[5,3,1]=-T[5,1,3];
T[6,2,3]=T[6,3,2]=1/2;
T[7,2,3]=-I/2;
T[7,3,2]=-T[7,2,3];
T[8,1,1]=T[8,2,2]=1/Sqrt[12];
T[8,3,3]=-1/Sqrt[3];

InsertTensors:={FormTracer`Private`FTxT[$SU3GellMannGroupName,a_,i_,j_]:>T[a,i,j], FormTracer`Private`FTxF[$SU3GellMannGroupName,a_,b_,c_]:>f[{a,b,c}]};

adjIndices=GetClosedAdjGroupIndices[deltasIntegrated,_];
fundIndices=GetClosedFundGroupIndices[deltasIntegrated,_];
If[adjIndices==={}&&fundIndices==={},Return[deltasIntegrated//.InsertTensors]];
preFactorSeparated=FormTracer`Private`separateFactors[deltasIntegrated,Alternatives@@First[FormTracer`Private`groupTensorsList]];
replacedTensors=Last[preFactorSeparated]//.InsertTensors;
Return[First[preFactorSeparated//.InsertTensors]*Sum[replacedTensors,Evaluate[Sequence@@Join[Table[{fundInd,dimFund},{fundInd,fundIndices}],Table[{adjInd,dimAdj},{adjInd,adjIndices}]]]]//integrateDeltas
];
];

InsertSU3GellManns[expr_]:=Module[
{dimAdj=8,dimFund=3,fg,f,T,deltasIntegrated,preFactorSeparated,replacedTensors,adjIndices,fundIndices,InsertTensors,
conv=InsertOutputNaming},

fg[{x_Integer,y_Integer,z_Integer}]:=0;
fg[{1,2,3}]=1;
fg[{1,4,7}]=1/2;
fg[{1,5,6}]=-1/2;
fg[{2,4,6}]=1/2;
fg[{2,5,7}]=1/2;
fg[{3,4,5}]=1/2;
fg[{3,6,7}]=-1/2;
fg[{4,5,8}]=Sqrt[3]/2;
fg[{6,7,8}]=Sqrt[3]/2;
f[list_List/;Length[list]==3&&IntegerQ[list[[1]]]&&IntegerQ[list[[2]]]&&IntegerQ[list[[3]]]]:=Signature[list]*fg[Sort[list]];

T[a_Integer,i_Integer,j_Integer]:=0;
T[0,_,_]:=(Print["ERROR: U3 is not supported as of now (but could be if necessary)!"];Abort[]);
(*T[0,1,1]=T[0,2,2]=T[0,3,3]=1/Sqrt[6];*)
T[1,1,2]=T[1,2,1]=1/2;
T[2,1,2]=-I/2;
T[2,2,1]=-T[2,1,2];
T[3,1,1]=1/2;
T[3,2,2]=-T[3,1,1];
T[4,1,3]=T[4,3,1]=1/2;
T[5,1,3]=-I/2;
T[5,3,1]=-T[5,1,3];
T[6,2,3]=T[6,3,2]=1/2;
T[7,2,3]=-I/2;
T[7,3,2]=-T[7,2,3];
T[8,1,1]=T[8,2,2]=1/Sqrt[12];
T[8,3,3]=-1/Sqrt[3];

InsertTensors:={
FormTracer`Private`FTxT[$SU3GellMannGroupName,a_Integer,i_Integer,j_Integer]:>T[a,i,j],
 FormTracer`Private`FTxF[$SU3GellMannGroupName,a_Integer,b_Integer,c_Integer]:>f[{a,b,c}],

conv@TBT[$SU3GellMannGroupName,a_Integer,i_Integer,j_Integer]:>T[a,i,j],
conv@TBF[$SU3GellMannGroupName,a_Integer,b_Integer,c_Integer]:>f[{a,b,c}],
conv@deltaFund[$SU3GellMannGroupName,a_Integer,a_Integer]:>1,
conv@deltaAdj[$SU3GellMannGroupName,a_Integer,a_Integer]:>1,
conv@deltaFund[$SU3GellMannGroupName,a_Integer,b_Integer]/;a!=b:>0,
conv@deltaAdj[$SU3GellMannGroupName,a_Integer,b_Integer]/;a!=b:>0
};
Return[expr//.InsertTensors//integrateDeltas//QuickSimplify]
];


(* ::Input::Initialization:: *)
PreTrace[expr_]:=Module[{exprExp},
Block[{Print},DisentangleLorentzStructures[False]];
exprExp=ExpandTerms[expr//integrateDeltas//InsertSU3GellManns];
Do[exprExp[[iDia,2,iFlavor,1]]=SU3GellMannTrace[ConvertInput[exprExp[[iDia,2,iFlavor,1]]]],{iDia,Length[exprExp]},{iFlavor,Length[exprExp[[iDia,2]]]}];
Return[ImplodeTerms[exprExp]//integrateDeltas//QuickSimplify];
];


finiteTFormExpansion="
id FTxsp(mom1?,mom2?)=(FTxsps(mom1,mom2)+FTxvec(mom1,0)*FTxvec(mom2,0));
argument;
id FTxsp(mom1?,mom2?)=(FTxsps(mom1,mom2)+FTxvec(mom1,0)*FTxvec(mom2,0));
argument;
id FTxsp(mom1?,mom2?)=(FTxsps(mom1,mom2)+FTxvec(mom1,0)*FTxvec(mom2,0));
argument;
id FTxsp(mom1?,mom2?)=(FTxsps(mom1,mom2)+FTxvec(mom1,0)*FTxvec(mom2,0));
endargument;
endargument;
endargument;
.sort
";
finiteTFormExpansionDis={{LorentzFormRule,finiteTFormExpansion},finiteTFormExpansion};


RemoveFromExtraVars[obj_]:=Module[{extraVars,postExtraVars},
extraVars=GetExtraVars[];
postExtraVars=If[MemberQ[extraVars,obj],DeleteCases[extraVars,obj],extraVars];

If[extraVars=!=postExtraVars,
DefineExtraVars[postExtraVars];Print["Error: Momentum \""<>ToString[obj]<>"\" had been defined as an extra variable in FormTracer!"];
Abort[];
];
];


FormMomentumExpansion[momenta__]:=Module[{Defs,code},
RemoveFromExtraVars/@{momenta};

Defs="Vector "<>StringTake[StringJoin[Map[ToString[#]<>","&,{momenta}]],{1,-2}]<>";";

code="*** definitions ***
"<>Defs<>"
*** rewrite/expand scalar products
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
endargument;
endargument;
endargument;
.sort

id FTxsp(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsp(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsp(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsp(mom1?,mom2?)=mom1.mom2;
endargument;
endargument;
endargument;
.sort

*** rewrite as FormTracer scalar products again ***
id mom1?.mom2?=FTxsp(mom1,mom2);
argument;
id mom1?.mom2?=FTxsp(mom1,mom2);
argument;
id mom1?.mom2?=FTxsp(mom1,mom2);
argument;
id mom1?.mom2?=FTxsp(mom1,mom2);
endargument;
endargument;
endargument;
.sort
";

Return[{{LorentzFormRule,code},code}];
];


FiniteTFormMomentumExpansion[momenta__]:=Module[{Defs,code},
RemoveFromExtraVars/@{momenta};

Defs="Vector "<>StringTake[StringJoin[Map[ToString[#]<>","&,{momenta}]],{1,-2}]<>";";

code=finiteTFormExpansion<>"*** definitions ***
"<>Defs<>"
*** rewrite/expand scalar products
id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
endargument;
endargument;
endargument;
.sort

id FTxsps(mom1?,mom2?)=mom1.mom2;
id FTxvec(mom1?,0)=mom1(0);
argument;
id FTxsps(mom1?,mom2?)=mom1.mom2;
id FTxvec(mom1?,0)=mom1(0);
argument;
id FTxsps(mom1?,mom2?)=mom1.mom2;
id FTxvec(mom1?,0)=mom1(0);
argument;
id FTxsps(mom1?,mom2?)=mom1.mom2;
id FTxvec(mom1?,0)=mom1(0);
endargument;
endargument;
endargument;
.sort

*** rewrite as FormTracer scalar products again ***
id mom1?.mom2?=FTxsps(mom1,mom2);
id mom1?(0)=FTxvec(mom1,0);
argument;
id mom1?.mom2?=FTxsps(mom1,mom2);
id mom1?(0)=FTxvec(mom1,0);
argument;
id mom1?.mom2?=FTxsps(mom1,mom2);
id mom1?(0)=FTxvec(mom1,0);
argument;
id mom1?.mom2?=FTxsps(mom1,mom2);
id mom1?(0)=FTxvec(mom1,0);
endargument;
endargument;
endargument;
.sort
";

Return[{{LorentzFormRule,code},code}];
];


MakeP0FormRule[q_,{momenta__},{projections__}]:=Module[
{momentaList,projectionsList,qf,nPt,Defs,repRules,freqRules,
externalFreqRule},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
projectionsList={projections};
qf=ToString[q]<>"f";

If[Length[momentaList]!=Length[projectionsList],Print["Momentum and projection list have differing length!"];Abort[]];

nPt=Length[momentaList];
Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>"intMom,intMomf;";
repRules=Thread[
Join[Map["exMom"<>ToString[#]&,Range[1,nPt]],{"intMomf","intMom","FTxI"}]->Join[Map[ToString,momentaList],{qf,ToString[q],"i_"}]
];
freqRules=StringTake[StringJoin[Map["id exMom"<>ToString[#]<>"(0)="<>ToString[CForm[projectionsList[[#]]/.Complex[re_,im_]:>re+FTxI im/.Thread[GetExtraVarsSynonyms[][[All,1]]->GetExtraVarsSynonyms[][[All,2]]]]]<>";\n"&,Range[1,nPt]]],{1,-2}];

externalFreqRule=finiteTFormExpansion<>Defs<>"

id FTxvec(mom1?,0)=mom1(0);
"<>freqRules<>"
id intMom(0)=FTxvec(intMom,0);
id intMomf(0)=FTxvec(intMomf,0);
argument;
id FTxvec(mom1?,0)=mom1(0);
"<>freqRules<>"
id intMom(0)=FTxvec(intMom,0);
id intMomf(0)=FTxvec(intMomf,0);
argument;
id FTxvec(mom1?,0)=mom1(0);
"<>freqRules<>"
id intMom(0)=FTxvec(intMom,0);
id intMomf(0)=FTxvec(intMomf,0);
argument;
id FTxvec(mom1?,0)=mom1(0);
"<>freqRules<>"
id intMom(0)=FTxvec(intMom,0);
id intMomf(0)=FTxvec(intMomf,0);
endargument;
endargument;
endargument;
.sort
";

externalFreqRule=StringReplace[externalFreqRule,repRules];
Return[{{LorentzFormRule,externalFreqRule},externalFreqRule}];
];


MakeFTCos[a_,b_]:=Module[{res},
res="cos"<>StringJoin[Map[ToString,Sort[{a,b}]]];
If[StringTake[res,-1]=="f",Return[Symbol[StringTake[res,{1,-2}]]],Return[Symbol[res]]]
];


GetFTSynonym[symbol_]:=Module[{},
If[symbol===I,Return[FTxI//ToString]];

If[Head[symbol]=!=Symbol,Print["The value \""<>ToString[symbol]<>"\" is not a symbol!"];Abort[]];

If[Not@MemberQ[GetExtraVarsSynonyms[],symbol,Infinity],AddExtraVars[symbol]];
ToString@Select[GetExtraVarsSynonyms[],#[[1]]==symbol&][[1,2]]
]


MakeSPFormRule[q_,p_,momenta__]:=Module[{momentaList,qf,Defs,nPt,nPtId,nPtCrossId,nPtqId,symmetricPointFiniteTFormRule4pt,repRules},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
qf=ToString[q]<>"f";

nPt=Length[momentaList];
Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>"avMom,intMom,intMomf;";
nPtId=StringJoin[
Map[
"id exMom"<>ToString[#]<>".exMom"<>ToString[#]<>"=avMom.avMom;\n"&
,Range[1,nPt]
]
];
nPtCrossId=StringJoin[
Map[
"id exMom"<>ToString[#[[1]]]<>".exMom"<>ToString[#[[2]]]<>"=-avMom.avMom/"<>ToString[nPt-1]<>";\n"&
,Subsets[Range[1,nPt],{2}]
]
];
nPtqId=StringJoin[Join[
Map[
"id exMom"<>ToString[#]<>".intMom=sqrt(avMom.avMom)*sqrt(intMom.intMom)*Cosq"<>ToString[#]<>";\n"&
,Range[1,nPt]
],
Map[
"id exMom"<>ToString[#]<>".intMomf=sqrt(avMom.avMom)*sqrt(intMom.intMom)*Cosq"<>ToString[#]<>";\n"&
,Range[1,nPt]
]
]];

symmetricPointFiniteTFormRule4pt="
*** definitions ***
"<>Defs<>"
*** rewrite/expand scalar products
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
endargument;
endargument;
endargument;
.sort

id FTxsp(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsp(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsp(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsp(mom1?,mom2?)=mom1.mom2;
endargument;
endargument;
endargument;
.sort

*** simplification ***
"<>nPtId<>nPtCrossId<>nPtqId<>"
argument;
"<>nPtId<>nPtCrossId<>nPtqId<>"
argument;
"<>nPtId<>nPtCrossId<>nPtqId<>"
argument;
"<>nPtId<>nPtCrossId<>nPtqId<>"
endargument;
endargument;
endargument;
.sort

*** rewrite as FormTracer scalar products again ***
id mom1?.mom2?=FTxsp(mom1,mom2);
argument;
id mom1?.mom2?=FTxsp(mom1,mom2);
argument;
id mom1?.mom2?=FTxsp(mom1,mom2);
argument;
id mom1?.mom2?=FTxsp(mom1,mom2);
endargument;
endargument;
endargument;
.sort
";
repRules=Thread[
Join[
Map["exMom"<>ToString[#]&,Range[1,nPt]],
Map["Cosq"<>ToString[#]&,Range[1,nPt]],
{"intMomf","intMom","avMom"}
]->
Join[
Map[ToString,momentaList],
Map[GetFTSynonym[MakeFTCos[momentaList[[#]],q]]&,Range[1,nPt]],
{qf,ToString[q],ToString[p]}
]
];
symmetricPointFiniteTFormRule4pt=StringReplace[symmetricPointFiniteTFormRule4pt,repRules];

Return[{{LorentzFormRule,symmetricPointFiniteTFormRule4pt},symmetricPointFiniteTFormRule4pt}];
];


MakeSPFormRule[q_,p_,momenta__]:=Module[{momentaList,qf,Defs,nPt,nPtId,nPtCrossId,nPtqId,symmetricPointFormRule4pt,repRules},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
qf=ToString[q]<>"f";

nPt=Length[momentaList];
Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>"avMom,intMom,intMomf;";
nPtId=StringJoin[
Map[
"id exMom"<>ToString[#]<>".exMom"<>ToString[#]<>"=avMom.avMom;\n"&
,Range[1,nPt]
]
];
nPtCrossId=StringJoin[
Map[
"id exMom"<>ToString[#[[1]]]<>".exMom"<>ToString[#[[2]]]<>"=-avMom.avMom/"<>ToString[nPt-1]<>";\n"&
,Subsets[Range[1,nPt],{2}]
]
];
nPtqId=StringJoin[Join[
Map[
"id exMom"<>ToString[#]<>".intMom=sqrt(avMom.avMom)*sqrt(intMom.intMom)*Cosq"<>ToString[#]<>";\n"&
,Range[1,nPt]
],
Map[
"id exMom"<>ToString[#]<>".intMomf=sqrt(avMom.avMom)*sqrt(intMom.intMom)*Cosq"<>ToString[#]<>";\n"&
,Range[1,nPt]
]
]];

symmetricPointFormRule4pt="
*** definitions ***
"<>Defs<>"
*** rewrite/expand scalar products
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsp(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
endargument;
endargument;
endargument;
.sort

id FTxsp(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsp(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsp(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsp(mom1?,mom2?)=mom1.mom2;
endargument;
endargument;
endargument;
.sort

*** simplification ***
"<>nPtId<>nPtCrossId<>nPtqId<>"
argument;
"<>nPtId<>nPtCrossId<>nPtqId<>"
argument;
"<>nPtId<>nPtCrossId<>nPtqId<>"
argument;
"<>nPtId<>nPtCrossId<>nPtqId<>"
endargument;
endargument;
endargument;
.sort

*** rewrite as FormTracer scalar products again ***
id mom1?.mom2?=FTxsp(mom1,mom2);
argument;
id mom1?.mom2?=FTxsp(mom1,mom2);
argument;
id mom1?.mom2?=FTxsp(mom1,mom2);
argument;
id mom1?.mom2?=FTxsp(mom1,mom2);
endargument;
endargument;
endargument;
.sort
";
repRules=Thread[
Join[
Map["exMom"<>ToString[#]&,Range[1,nPt]],
Map["Cosq"<>ToString[#]&,Range[1,nPt]],
{"intMomf","intMom","avMom"}
]->
Join[
Map[ToString,momentaList],
Map[GetFTSynonym[MakeFTCos[momentaList[[#]],q]]&,Range[1,nPt]],
{qf,ToString[q],ToString[p]}
]
];
symmetricPointFormRule4pt=StringReplace[symmetricPointFormRule4pt,repRules];

Return[{{LorentzFormRule,symmetricPointFormRule4pt},symmetricPointFormRule4pt}];
];


MakeSPFiniteTFormRule[q_,p_,momenta__]:=Module[{momentaList,qf,Defs,nPt,nPtId,nPtCrossId,nPtqId,symmetricPointFiniteTFormRule4pt,repRules},
RemoveFromExtraVars/@{momenta};

momentaList={momenta};
qf=ToString[q]<>"f";

nPt=Length[momentaList];
Defs="Vector "<>StringJoin[Map["exMom"<>ToString[#]<>","&,Range[1,nPt]]]<>"avMom,intMom,intMomf;";
nPtId=StringJoin[
Map[
"id exMom"<>ToString[#]<>".exMom"<>ToString[#]<>"=avMom.avMom;\n"&
,Range[1,nPt]
]
];
nPtCrossId=StringJoin[
Map[
"id exMom"<>ToString[#[[1]]]<>".exMom"<>ToString[#[[2]]]<>"=-avMom.avMom/"<>ToString[nPt-1]<>";\n"&
,Subsets[Range[1,nPt],{2}]
]
];
nPtqId=StringJoin[Join[
Map[
"id exMom"<>ToString[#]<>".intMom=sqrt(avMom.avMom)*sqrt(intMom.intMom)*Cosq"<>ToString[#]<>";\n"&
,Range[1,nPt]
],
Map[
"id exMom"<>ToString[#]<>".intMomf=sqrt(avMom.avMom)*sqrt(intMom.intMom)*Cosq"<>ToString[#]<>";\n"&
,Range[1,nPt]
]
]];

symmetricPointFiniteTFormRule4pt=finiteTFormExpansion<>"

*** definitions ***
"<>Defs<>"
*** rewrite/expand scalar products
id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
argument;
id FTxsps(mom1?,mom2?)^-1=pow(mom1.mom2,-1);
endargument;
endargument;
endargument;
.sort

id FTxsps(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsps(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsps(mom1?,mom2?)=mom1.mom2;
argument;
id FTxsps(mom1?,mom2?)=mom1.mom2;
endargument;
endargument;
endargument;
.sort

*** simplification ***
"<>nPtId<>nPtCrossId<>nPtqId<>"
argument;
"<>nPtId<>nPtCrossId<>nPtqId<>"
argument;
"<>nPtId<>nPtCrossId<>nPtqId<>"
argument;
"<>nPtId<>nPtCrossId<>nPtqId<>"
endargument;
endargument;
endargument;
.sort

*** rewrite as FormTracer scalar products again ***
id mom1?.mom2?=FTxsps(mom1,mom2);
argument;
id mom1?.mom2?=FTxsps(mom1,mom2);
argument;
id mom1?.mom2?=FTxsps(mom1,mom2);
argument;
id mom1?.mom2?=FTxsps(mom1,mom2);
endargument;
endargument;
endargument;
.sort
";
repRules=Thread[
Join[
Map["exMom"<>ToString[#]&,Range[1,nPt]],
Map["Cosq"<>ToString[#]&,Range[1,nPt]],
{"intMomf","intMom","avMom"}
]->
Join[
Map[ToString,momentaList],
Map[GetFTSynonym[MakeFTCos[momentaList[[#]],q]]&,Range[1,nPt]],
{qf,ToString[q],ToString[p]}
]
];
symmetricPointFiniteTFormRule4pt=StringReplace[symmetricPointFiniteTFormRule4pt,repRules];

Return[{{LorentzFormRule,symmetricPointFiniteTFormRule4pt},symmetricPointFiniteTFormRule4pt}];
];


ReplaceFormBraces[result_String]:=Module[{newRes,regEx,bracePositions,repTruth,repList,ob},
regEx=RegularExpression@"(?P<a>\\(([^\\(\\)]|(?P>a))*\\))";
bracePositions=StringPosition[result,regEx];
repTruth=Map[
If[ob=StringTake[result,{#[[1]]-1}];ob=="*"||ob=="/",
False,
True]&,bracePositions];
repList=Select[
Table[If[repTruth[[i]],bracePositions[[i]],{}],{i,1,Length[bracePositions]}],
#=!={}&
];
newRes=StringReplacePart[result,"[",Transpose@{repList[[All,1]],repList[[All,1]]}];
newRes=StringReplacePart[newRes,"]",Transpose@{repList[[All,2]],repList[[All,2]]}];
Return[newRes];
];


OptimizedFormTrace::usage="OptimizedFormTrace[expr_,filename_String,preRepRules_:{},postRepRules_:{}]";
OptimizedFormTrace[expr_,filename_String,preRepRules_:{},postRepRules_:{}]:=Module[
{synonyms,backReplacements,result,FTxVAR,FTxTMP},

FormTrace[expr,preRepRules,postRepRules,{filename,"O4","nospaces"},{},ToString@FTxVAR,StringReplace[ToString@FTxTMP,"$"->""]];

synonyms=GetExtraVarsSynonyms[];
backReplacements=Dispatch@Join[Thread[synonyms[[All,2]]->synonyms[[All,1]]],{FTxsps->sps,FTxsp->sp}];

result=StringReplace[
ReplaceFormBraces@Import[filename,"Text"],
{"pow"->"Power","sqrt"->"Sqrt"}
];
result=StringReplace[result,"\n"->""];
result=result//ToExpression;

Return[FTxVAR//.backReplacements];
];


ExtendedFormTrace[expr_,disentangle:_?BooleanQ:True,preRepRules_List:{},postRepRules_List:{}]:=Module[{preExpr},
preExpr=ResolveChargeConjugation[integrateDeltas[expr]]//integrateDeltas;
If[$UseSU3GellMannTrace,
preExpr=PreTrace[preExpr]
];
Block[{Print},DisentangleLorentzStructures[disentangle]];
FormTrace[preExpr//integrateDeltas,preRepRules,postRepRules]
]
ExtendedFormTrace[expr_List,disentangle:_?BooleanQ:True,preRepRules_List:{},postRepRules_List:{}]:=Module[{preExpr},
Total[Flatten@Map[ExtendedFormTrace[#,disentangle,preRepRules,postRepRules]&,expr]]
]


SeparateScalarProductsFiniteT[expr_]:=Module[{},UseLorentzLinearity[expr]//.InsertOutputNaming@{TBsp[q_,p_]:>TBsps[q,p]+TBvec[q,0]TBvec[p,0],TBvec[p_,mu_/;mu=!=0]:>TBvecs[p,mu]+TBdeltaLorentz[mu,0]TBvec[p,0]}]

ExpandScalarProductsFiniteT[expr_]:=Module[{q,p},UseLorentzLinearity[expr]//.InsertOutputNaming@{TBsp[q_,p_]->TBsps[q,p]+TBvec[q,0]TBvec[p,0]}//.InsertOutputNaming@{TBsps[q_,p_]->q p cos[q,p], cos[p_,p_]->1}]

ExpandScalarProducts[expr_]:=Module[{q,p},UseLorentzLinearity[expr]//.InsertOutputNaming@{TBsp[q_,p_]->q p cos[q,p], cos[p_,p_]->1}]

SetAttributes[cos, Orderless];
Derivative[0,1][cos][p_,q_]=0;
Derivative[1,0][cos][p_,q_]=0;
cos[p_,p_]=1;

SimplifyAllMomenta[q_,expr_,qffac_:\[Pi] T]:=UseLorentzLinearity[expr]//.InsertOutputNaming@{
cos[p_,Symbol[ToString[q]<>"f"]]:>Symbol["cos"<>ToString[p]<>ToString[q]],
TBvec[q,0]:>Symbol[ToString[q]<>"0"],
TBvec[Symbol[ToString[q]<>"f"],0]:>(ClearAll[T];Symbol[ToString[q]<>"0"]+qffac)
}//.InsertOutputNaming@{
cos[p_,r_]:>Symbol["cos"<>ToString[p]<>ToString[r]],
TBvec[p_,0]:>Symbol[ToString[p]<>"0"],
Symbol[ToString[q]<>"f"]->q
}


ProjectToSymmetricPoint[expr_,q_Symbol,p_Symbol,momenta___Symbol]:=Module[{momentaList,nMomenta,rules,qf,
conv=InsertOutputNaming},
momentaList={momenta};
nMomenta=Length[momentaList];
qf=Symbol[ToString[q]<>"f"];
rules=Map[conv@TBsp[#[[1]],#[[2]]]->-(1/(nMomenta-1))conv@TBsp[p,p]&,Subsets[momentaList,{2}]]
\[Union]Map[conv@TBsp[#,#]->conv@TBsp[p,p]&,momentaList]
\[Union]Map[conv@TBsp[#,q]->Symbol["cos"~~ToString[#]~~"q"] p q&,momentaList]
\[Union]Map[conv@TBsp[#,qf]->Symbol["cos"~~ToString[#]~~"q"] p qf&,momentaList]
(*\[Union]{momentaList[[nMomenta]]->-Total[momentaList[[1;;nMomenta-1]]]}*);
(UseLorentzLinearity[expr]//.rules//UseLorentzLinearity)//.rules
]


ProjectToSymmetricPointFiniteT[expr_,q_Symbol,p_Symbol,momenta___Symbol]:=Module[{momentaList,nMomenta,rules,qf,
conv=InsertOutputNaming},
momentaList={momenta};
nMomenta=Length[momentaList];
qf=Symbol[ToString[q]<>"f"];
rules=Map[conv@TBsps[#[[1]],#[[2]]]->-(1/(nMomenta-1))conv@TBsps[p,p]&,Subsets[momentaList,{2}]]
\[Union]Map[conv@TBsps[#,#]->conv@TBsps[p,p]&,momentaList]
\[Union]Map[conv@TBsps[#,q]->Symbol["cos"~~ToString[#]~~"q"] p q&,momentaList]
\[Union]Map[conv@TBsps[#,qf]->Symbol["cos"~~ToString[#]~~"q"] p qf&,momentaList]
(*\[Union]{momentaList[[nMomenta]]->-Total[momentaList[[1;;nMomenta-1]]]}*);
(SeparateScalarProductsFiniteT[UseLorentzLinearity[expr]]//.rules//UseLorentzLinearity)//.rules
]


(* ::Input::Initialization:: *)
QuickSimplify[expr_] := Simplify[expr,TimeConstraint -> 0.1] // Quiet;


$StandardSimplify=Simplify;
SetStandardSimplify[sim_]:=Module[{},
$StandardSimplify=sim;
]
$StandardQuickSimplify=QuickSimplify;
SetStandardQuickSimplify[sim_]:=Module[{},
$StandardQuickSimplify=sim;
]


AdjustToNKernels[nKernels_Integer]:=Module[{},
If[nKernels!=0,
CloseKernels[];
LaunchKernels[nKernels];
DistributeDefinitions["TensorBases`Private`"];
DistributeDefinitions["FormTracer`"];
DistributeDefinitions[ExtendedFormTrace,InsertChargeConjRules]
];
]
RestoreKernels[]:=Module[{},
CloseKernels[];
LaunchKernels[];
DistributeDefinitions["TensorBases`Private`"];
DistributeDefinitions["FormTracer`"];
DistributeDefinitions[ExtendedFormTrace,InsertChargeConjRules];
]
DiFfRGMap[nKernels_Integer]:=Module[{},
If[nKernels<=1,
Return[ResourceFunction["DynamicMap"]],
Return[ResourceFunction["DynamicMap"][#1,#2,Parallel->nKernels]&]
];
];


ClearAll[IterativelySum];
IterativelySum[expr_List,nKernels_Integer]:=Module[
{returnValue},

returnValue=expr;
If[Length[returnValue]==1,Return[returnValue]];

While[Length[returnValue]>1,
returnValue=DiFfRGMap[nKernels][
$StandardQuickSimplify[Total[#]]&
,Partition[returnValue,UpTo[4]]]
];

Return[$StandardQuickSimplify[returnValue]];
]


IterativelySum[expr_List,nKernels_Integer,finalSize_Integer/;finalSize>=0]:=Module[
{processLists,returnValue,i},

If[finalSize==0,
Return[IterativelySum[expr,nKernels][[1]]];
];

processLists=expr;
If[Length[processLists]==finalSize,Return[processLists]];

processLists=Sort[processLists,(ByteCount[#1]>ByteCount[#2])&];
processLists=Table[Downsample[processLists,finalSize,i],{i,1,finalSize}];

returnValue=Map[IterativelySum[#,nKernels]&,processLists];

Return[Flatten[returnValue]]
];


SetDisentangle[ex_]:=Module[{},
$Disentangle=ex;
];
$Disentangle=True;


SumDiagrams[nKernels_Integer,postfix_String,number_Integer:0,operation_:$StandardQuickSimplify,saveName_String:"sum"]:=Module[
{tempDir,files,data,mAssume,returnValue},

tempDir=GetDirectory[]<>"TraceBuffer/";

If[FileExistsQ[tempDir<>postfix<>"/"<>saveName<>".m"],
Print["Using result \""<>tempDir<>postfix<>"/"<>saveName<>".m"<>"\" from buffer..."];
Return[Import[tempDir<>postfix<>"/"<>saveName<>".m"]];
];

If[number<0,Print["Cannot sum to negative size."];Abort[]];

files=FileNames[tempDir<>postfix<>"/Diagram*"];
AdjustToNKernels[nKernels];

mAssume=$Assumptions;
data=DiFfRGMap[nKernels][
Assuming[mAssume,operation[Import[#]]]&
,files
];

returnValue=IterativelySum[data,nKernels,number];

RestoreKernels[];
Export[tempDir<>postfix<>"/"<>saveName<>".m",returnValue];
Return[returnValue]
];


(* ::Input::Initialization:: *)
TraceDiagrams[nKernels_Integer,postfix_String,ex_,preRepRules_List:{},postRepRules_List:{}]:=TraceDiagrams[$StandardSimplify,nKernels,postfix,ex,preRepRules,postRepRules];
TraceDiagrams[simpFunc_,nKernels_Integer,postfix_String,ex_,preRepRules_List:{},postRepRules_List:{}]:=Module[
{returnValue,files,tempDir},

tempDir=GetDirectory[]<>"TraceBuffer/";

Print["Tracing..."];
AdjustToNKernels[nKernels];
If[Not@DirectoryQ[tempDir<>postfix],CreateDirectory[tempDir<>postfix]];

DisentangleLorentzStructures[$Disentangle];
DiFfRGMap[nKernels][
(If[FileExistsQ[tempDir<>postfix<>"/Diagram"<>ToString[#]<>".m"],
tempDir<>postfix<>"/Diagram"<>ToString[#]<>".m",
Export[tempDir<>postfix<>"/Diagram"<>ToString[#]<>".m",
simpFunc[
ExtendedFormTrace[ex[[#]],$Disentangle,preRepRules,postRepRules]
]
]
]
)&
,Table[i,{i,1,Length[ex]}]
];

Print["...done."];
];


(* ::Input::Initialization:: *)
TraceToSP[nKernels_Integer,postfix_String,ex_,q_Symbol,p_Symbol,momenta___Symbol]:=TraceToSP[$StandardSimplify,nKernels,postfix,ex,q,p,momenta];
TraceToSP[simpFunc_,nKernels_Integer,postfix_String,ex_,q_Symbol,p_Symbol,momenta___Symbol]:=Module[{returnValue,files,tempDir},

tempDir=GetDirectory[]<>"TraceBuffer/";

Print["Tracing..."];
AdjustToNKernels[nKernels];
If[Not@DirectoryQ[tempDir<>postfix],CreateDirectory[tempDir<>postfix]];

DisentangleLorentzStructures[$Disentangle];
DiFfRGMap[nKernels][
(If[FileExistsQ[tempDir<>postfix<>"/Diagram"<>ToString[#]<>".m"],
tempDir<>postfix<>"/Diagram"<>ToString[#]<>".m",
Export[tempDir<>postfix<>"/Diagram"<>ToString[#]<>".m",
simpFunc[
ExtendedFormTrace[ex[[#]],$Disentangle,{},MakeSPFormRule[q,p,momenta]]
]
]
]
)&
,Table[i,{i,1,Length[ex]}]
];

Print["...done."];
]


(* ::Input::Initialization:: *)
TraceToSPFiniteT[nKernels_Integer,postfix_String,ex_,q_Symbol,p_Symbol,momenta___Symbol]:=TraceToSPFiniteT[$StandardSimplify,nKernels,postfix,ex,q,p,momenta];
TraceToSPFiniteT[simpFunc_,nKernels_Integer,postfix_String,ex_,q_Symbol,p_Symbol,momenta___Symbol]:=Module[{returnValue,files,tempDir},

tempDir=GetDirectory[]<>"TraceBuffer/";

Print["Tracing..."];
AdjustToNKernels[nKernels];
If[Not@DirectoryQ[tempDir<>postfix],CreateDirectory[tempDir<>postfix]];

DisentangleLorentzStructures[$Disentangle];
DiFfRGMap[nKernels][
(If[FileExistsQ[tempDir<>postfix<>"/Diagram"<>ToString[#]<>".m"],
tempDir<>postfix<>"/Diagram"<>ToString[#]<>".m",
Export[tempDir<>postfix<>"/Diagram"<>ToString[#]<>".m",
simpFunc[
ExtendedFormTrace[ex[[#]],$Disentangle,{},MakeSPFiniteTFormRule[q,p,momenta]]
]
]
]
)&
,Table[i,{i,1,Length[ex]}]
,"Parallel"->If[nKernels>0,nKernels,False]
];

Print["...done."];
]


(*End[]*)


Protect["DiFfRG`*"];


(*EndPackage[];*)


AddCodeOptimizeFunctions[RBdot[__],RFdot[__],RB[__],RF[__]]
