(* ::Package:: *)

(************************************************************************)\012(* This file was generated automatically by the Mathematica front end.  *)\012(* It contains Initialization cells from a Notebook file, which         *)\012(* typically will have the same name as this file except ending in      *)\012(* ".nb" instead of ".m".                                               *)\012(*                                                                      *)\012(* This file is intended to be loaded into the Mathematica kernel using *)\012(* the package loading commands Get or Needs.  Doing so is equivalent   *)\012(* to using the Evaluate Initialization Cells menu command in the front *)\012(* end.                                                                 *)\012(*                                                                      *)\012(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)\012(* automatically each time the parent Notebook file is saved in the     *)\012(* Mathematica front end.  Any changes you make to this file will be    *)\012(* overwritten.                                                         *)\012(************************************************************************)\012\012

Print["Mathematica package \!\(\*
StyleBox[\"DiFfRG\",\nFontWeight->\"Bold\"]\)\!\(\*
StyleBox[\" \",\nFontWeight->\"Bold\"]\)loaded
\!\(\*
StyleBox[\"Authors\",\nFontWeight->\"Bold\"]\): Franz Richard Sattler
\!\(\*
StyleBox[\"Version\",\nFontWeight->\"Bold\"]\): 2.0
\!\(\*
StyleBox[\"Year\",\nFontWeight->\"Bold\"]\): 2025
"]


DiFfRG::FunKitRequired="\!\(\*
StyleBox[\"DiFfRG\",\nFontWeight->\"Bold\"]\) requires \!\(\*
StyleBox[\"FunKit\",\nFontWeight->\"Bold\"]\) to run.";

If[Length@PacletFind["FunKit"]===0,
If[ChoiceDialog["FunKit does not seem to be installed. Do you want to install it?",WindowTitle->"Install TensorBases",WindowSize->{Medium,All}],
Import["https://raw.githubusercontent.com/satfra/TensorBases/main/TensorBasesInstaller.m"],
Message[DiFfRG::FunKitRequired];Abort[];
];
]
Get["FunKit`"]


Get["DiFfRG`CodeTools`"];


(* ::Input::Initialization:: *)
(*BeginPackage["DiFfRG`"];*)
Unprotect["DiFfRG`*"];
Unprotect["DiFfRG`Private`*"];
ClearAll["DiFfRG`*"];
ClearAll["DiFfRG`Private`*"];


GetDirectory::usage="GetDirectory[]
Returns the directory in which either the package file or notebook is located.";

AutoExport::usage="AutoExport[]
Turns on automatic export of the current notebook to a .m file.";

AutoSaveRestore::usage="AutoSaveRestore[fileName_String,expr_]
Evaluates expr if the file fileName does not yet exist and saves it to fileName as a .m file. If fileName exists, it does not evaluate expr, but simply loads the contents.";


MatsubaraSum::usage = "MatsubaraSum[expr_,p0_Symbol,T_]
Sums the expression expr over p0, with p0 = 2\[Pi]T*n, where n\[Element]\[CapitalZeta].";
FermionMatsubaraSum::usage = "FermionMatsubaraSum[expr_,p0_Symbol,T_]
Sums the expression expr over p0, with p0 = (2*n+1)\[Pi]T, where n\[Element]\[CapitalZeta].";


ResolveChargeConjugation::usage="ResolveChargeConjugation[expr_]
Resolves all occurences of ChargeConj[i,j] by using the effect of these in Weyl representation.";


UseSU3GellMannTrace::usage="SU3GellMannTrace[value_?BooleanQ,groupName_String:\"color\"]
Traces the generators of the fundamental representation in the given group as SU(3) Gell-Mann matrices explicitly.";


PreTrace::usage="PreTrace[expr_]
Resolve charge conjugation and perform possibly the explicit color trace."


FormMomentumExpansion::usage="FormMomentumExpansion[momenta___]"
FiniteTFormMomentumExpansion[momenta__]


MakeP0FormRule::usage="MakeP0FormRule[q_,{momenta__},{projections__}]"
GetFTSynonym::usage="GetFTSynonym[symbol_]"
MakeSPFormRule::usage="MakeSPFormRule[q_,p_,momenta__]"
MakeSPFormRule::usage="MakeSPFormRule[q_,p_,momenta__]"
MakeSPFiniteTFormRule::usage="MakeSPFiniteTFormRule[q_,p_,momenta__]"
ExtendedFormTrace::usage="ExtendedFormTrace[expr_,disentangle:_?BooleanQ:True,preRepRules_List:{},postRepRules_List:{}]"

SeparateScalarProductsFiniteT::usage="SeparateScalarProductsFiniteT[expr_]"
ExpandScalarProductsFiniteT::usage="ExpandScalarProductsFiniteT[expr_]"
ExpandScalarProducts::usage="ExpandScalarProducts[expr_]"
SimplifyAllMomenta::usage="SimplifyAllMomenta[q_,expr_]"
ProjectToSymmetricPoint::usage="ProjectToSymmetricPoint[expr_,q_Symbol,p_Symbol,momenta___Symbol]"
ProjectToSymmetricPointFiniteT::usage="ProjectToSymmetricPointFiniteT[expr_,q_Symbol,p_Symbol,momenta___Symbol]"

QuickSimplify::usage="QuickSimplify[expr_]"
SetStandardQuickSimplify::usage="SetStandardQuickSimplify[sim_]"
SetStandardSimplify::usage="SetStandardSimplify[sim_]"

SetDisentangle::usage="SetDisentangle[ex_]"
SumDiagrams::usage="SumDiagrams[nKernels_Integer,postfix_String,number_Integer:0,operation_:$StandardQuickSimplify,saveName_String:\"sum\"]";
TraceDiagrams::usage="TraceDiagrams[simpFunc_,nKernels_Integer,postfix_String,ex_,preRepRules_List:{},postRepRules_List:{}]"
DiracTranspose::usage = "DiracTranspose[expression] switches two open dirac indices";


(*Begin["`Private`"]*)


Unprotect[GetDirectory];
GetDirectory[]:=If[$Notebooks,NotebookDirectory[],Directory[]]<>"/";


(* ::Input::Initialization:: *)
AutoExport[Switch:_?BooleanQ:True]:=If[Switch,
SetOptions[EvaluationNotebook[],{
AutoGeneratedPackage->Automatic,
InitializationCellEvaluation->False,
InitializationCellWarning->False,StyleDefinitions->Notebook[
{Cell[StyleData[StyleDefinitions->"Default.nb"]],Cell[StyleData["Input"],InitializationCell->True]},Visible->False,StyleDefinitions->"PrivateStylesheetFormatting.nb"
]}],
SetOptions[EvaluationNotebook[],{
AutoGeneratedPackage->False
}]
];


AutoSaveRestore[fileName_String,expr_]:=Module[{ret},
If[FileExistsQ[fileName<>".m"],
ret=Import[fileName<>".m"];
Print["Imported existing file \""<>fileName<>".m"<>"\"..."];
,
ret=ReleaseHold[expr];
Export[fileName<>".m",ret];
Print["Saved to file \""<>fileName<>".m"<>"\"..."];
];
ret
];
SetAttributes[AutoSaveRestore,HoldRest];


ClearAll[MatsubaraSumHelper,FermionMatsubaraSum,MatsubaraSum]
Options[FermionMatsubaraSum]={Debug->False};
Options[MatsubaraSum]={Debug->True};
MatsubaraSumHelper[expr_,p0_Symbol,T_,fun_,debug_]:=Module[{denom,poles,residues,n,r,SumB},
If[Head[expr]==Plus,Return[Total[Flatten[Map[MatsubaraSum[#,p0,T]&,List@@expr],1]]]];denom = Denominator[expr]//Collect[#,p0]&;
poles=p0/.Solve[denom==0,p0]//FullSimplify;
poles = Assuming[T>0&&_Symbol\[Element]Reals,poles//FullSimplify];
If[debug,
Print["Poles found at:"];
Print/@poles;
];
residues={};For[n=1,n<=Length[poles],n++,
r=Simplify[Residue[expr*fun[I*p0/(2T)],{p0,poles[[n]]}]];
AppendTo[residues,r];];
SumB=1/(2I) residues;
Total[SumB]
];
MatsubaraSum[expr_,p0_Symbol,T_,OptionsPattern[]]:=MatsubaraSumHelper[expr,p0,T,Coth,OptionValue[Debug]]
FermionMatsubaraSum[expr_,p0_Symbol,T_,OptionsPattern[]]:=MatsubaraSumHelper[expr,p0,T,Tanh,OptionValue[Debug]]


InsertOutputNaming[expr_]:=Module[
{
groups,
outputRulesLorentzTensors,outputRulesGroupTensors,outputRules,
privateOutputRulesLorentzTensors,privateOutputRulesGroupTensors,privateOutputRules,
otherRules
},

outputRulesLorentzTensors=Normal[FormTracer`Private`lorentzTensorReplacementRulesOutput]/.{(a_[c___]:>b_):>(Symbol["TB"~~StringSplit[ToString[a],"FTx"][[-1]]][c]:>b)};
outputRulesGroupTensors=Normal[FormTracer`Private`groupTensorReplacementRulesOutput]/.{(a_[c___]:>b_):>(Symbol["TB"~~StringSplit[ToString[a],"FTx"][[-1]]][c]:>b)};
outputRules=Join[outputRulesLorentzTensors,outputRulesGroupTensors];

Return[
Evaluate[expr//.outputRules]
];
];


InsertInputNaming[expr_]:=Module[
{
inputRulesLorentzTensors,inputRulesGroupTensors
},

inputRulesLorentzTensors=Select[Normal[FormTracer`Private`lorentzTensorReplacementRulesInput],MatchQ[_[__]:>_[__]]]/.{
(a_[d__]:>b_[c__]):>(a[d]->Symbol["TB"~~StringSplit[ToString[b],"FTx"][[-1]]][c])
};
inputRulesGroupTensors=Select[Normal[FormTracer`Private`groupTensorReplacementRulesInput],MatchQ[_[__]:>_[__]]]/.{
(a_[d__]:>b_[c__]):>(a[d]->Symbol["TB"~~StringSplit[ToString[b],"FTx"][[-1]]][c])
};

Return[
expr//.inputRulesLorentzTensors//.inputRulesGroupTensors/.a_Symbol:>Symbol["Global`"~~SymbolName[a]]
];
];


ImplodeTerms[expr_]:=expr;
ImplodeTerms[expr_List]:=Module[{ret},
If[Head[expr[[1]]]===List,
Plus@@Map[ImplodeTerms,expr],
Times@@Map[ImplodeTerms,expr]
]
];
CollapseTerms[expr_]:=expr;
CollapseTerms[expr_List]:=Total[Map[#[[1]]*CollapseTerms[#[[2]]]&,expr]];

FixChargeConj[expr_]:=
Module[{ret,restoreIdx,rule,chargeRules},
Block[{Print},DisentangleLorentzStructures[False]];
ret=expr;
restoreIdx={};
ret=ret//.ChargeConj[a_,b_]:>Module[{},restoreIdx=Append[restoreIdx,{a,b}];InsertOutputNaming[TBdeltaDirac[a,b]]];
rule=Map[InsertOutputNaming[TBdeltaDirac[#[[1]],#[[2]]]]:>ChargeConj[#[[1]],#[[2]]]&,restoreIdx];
ret=FormTracer`ExpandTerms[ret]//.rule//Expand//InsertOutputNaming;

chargeRules={
TBgamma[mu_,a_,c_]ChargeConj[a_,b_]:>-ChargeConj[c,a]TBgamma[mu,a,b],
TBgamma[mu_,a_,b_]ChargeConj[b_,c_]:>-ChargeConj[a,b]TBgamma[mu,c,b],

TBgamma5[a_,c_]ChargeConj[a_,b_]:>ChargeConj[c,a]TBgamma5[a,b],
TBgamma5[a_,b_]ChargeConj[b_,c_]:>ChargeConj[a,b]TBgamma5[c,b],

TBdeltaDirac[a_,b_]ChargeConj[b_,c_]:>ChargeConj[a,c],
TBdeltaDirac[a_,b_]ChargeConj[c_,b_]:>ChargeConj[c,a],
TBdeltaDirac[b_,a_]ChargeConj[b_,c_]:>ChargeConj[a,c],

ChargeConj[a_,b_]ChargeConj[a_,c_]:>deltaDirac[b,c],
ChargeConj[a_,b_]ChargeConj[c_,b_]:>deltaDirac[a,c],
ChargeConj[a_,b_]ChargeConj[b_,c_]:>-deltaDirac[a,c]
}//InsertOutputNaming;
ret=ret//.chargeRules;

(*This is chiral Weyl representation-specific.*)
ret=ret//.{ChargeConj[a_,b_]:>Module[{dint},TBgamma[2,a,dint]TBgamma[0,dint,b]]};
Return[ImplodeTerms[ret]//InsertOutputNaming];
];

ResolveChargeConjugation[expr_]:=Module[{},
If[
MemberQ[expr,ChargeConj[__],Infinity],
expr//FixChargeConj
,
expr
]
];


integrateDeltas[expr_]:=Module[{list1,list2,conv=InsertOutputNaming},
list1={
FormTracer`Private`FTxdeltaLorentz[a_,b_]FormTracer`Private`FTxdeltaLorentz[a_,c_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaLorentz[b,c],
conv@TBdeltaLorentz[a_,b_]conv@TBdeltaLorentz[a_,c_]/;Not[NumberQ[a]]:>conv@TBdeltaLorentz[b,c],

FormTracer`Private`FTxdeltaLorentz[a_,b_]FormTracer`Private`FTxdeltaLorentz[c_,a_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaLorentz[b,c],
conv@TBdeltaLorentz[a_,b_]conv@TBdeltaLorentz[c_,a_]/;Not[NumberQ[a]]:>conv@TBdeltaLorentz[b,c],

FormTracer`Private`FTxdeltaLorentz[b_,a_]FormTracer`Private`FTxdeltaLorentz[a_,c_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaLorentz[b,c],
conv@TBdeltaLorentz[b_,a_]conv@TBdeltaLorentz[a_,c_]/;Not[NumberQ[a]]:>conv@TBdeltaLorentz[b,c],

FormTracer`Private`FTxdeltaLorentz[b_,a_]FormTracer`Private`FTxdeltaLorentz[c_,a_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaLorentz[b,c],
conv@TBdeltaLorentz[b_,a_]conv@TBdeltaLorentz[c_,a_]/;Not[NumberQ[a]]:>conv@TBdeltaLorentz[b,c],

FormTracer`Private`FTxdeltaLorentz[a_,a_]:>If[NumberQ[a],1,4],
conv@TBdeltaLorentz[a_,a_]:>If[NumberQ[a],1,4],

conv@TBvec[p_,a_]conv@TBdeltaLorentz[a_,b_]conv@TBvec[q_,b_]:>conv@TBsp[p,q] ,
conv@TBvec[p_,a_]conv@TBdeltaLorentz[b_,a_]conv@TBvec[q_,b_]:>conv@TBsp[p,q] ,
conv@TBvecs[p_,a_]conv@TBdeltaLorentz[a_,b_]conv@TBvecs[q_,b_]:>conv@TBsps[p,q] ,
conv@TBvecs[p_,a_]conv@TBdeltaLorentz[b_,a_]conv@TBvecs[q_,b_]:>conv@TBsps[p,q] 
};
list2={
FormTracer`Private`FTxdeltaDirac[a_,b_]FormTracer`Private`FTxdeltaDirac[a_,c_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaDirac[b,c],
conv@TBdeltaDirac[a_,b_]conv@TBdeltaDirac[a_,c_]/;Not[NumberQ[a]]:>conv@TBdeltaDirac[b,c],

FormTracer`Private`FTxdeltaDirac[a_,b_]FormTracer`Private`FTxdeltaDirac[c_,a_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaDirac[b,c],
conv@TBdeltaDirac[a_,b_]conv@TBdeltaDirac[c_,a_]/;Not[NumberQ[a]]:>conv@TBdeltaDirac[c,b],

FormTracer`Private`FTxdeltaDirac[b_,a_]FormTracer`Private`FTxdeltaDirac[a_,c_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaDirac[b,c],
conv@TBdeltaDirac[b_,a_]conv@TBdeltaDirac[a_,c_]/;Not[NumberQ[a]]:>conv@TBdeltaDirac[b,c],

FormTracer`Private`FTxdeltaDirac[b_,a_]FormTracer`Private`FTxdeltaDirac[c_,a_]/;Not[NumberQ[a]]:>FormTracer`Private`FTxdeltaDirac[b,c],
conv@TBdeltaDirac[b_,a_]conv@TBdeltaDirac[c_,a_]/;Not[NumberQ[a]]:>conv@TBdeltaDirac[b,c],

FormTracer`Private`FTxdeltaDirac[a_,a_]:>If[NumberQ[a],1,4],
conv@TBdeltaDirac[a_,a_]:>If[NumberQ[a],1,4],

conv@TBdeltaDirac[b_,a_]conv@TBgamma[mu_,c_,a_]/;Not[NumberQ[a]]:>conv@TBgamma[mu,c,b],
conv@TBdeltaDirac[a_,b_]conv@TBgamma[mu_,c_,a_]/;Not[NumberQ[a]]:>conv@TBgamma[mu,c,b],
conv@TBdeltaDirac[b_,a_]conv@TBgamma[mu_,a_,c_]/;Not[NumberQ[a]]:>conv@TBgamma[mu,b,c],
conv@TBdeltaDirac[a_,b_]conv@TBgamma[mu_,a_,c_]/;Not[NumberQ[a]]:>conv@TBgamma[mu,b,c],

conv@TBdeltaDirac[b_,a_]conv@TBgamma5[c_,a_]/;Not[NumberQ[a]]:>conv@TBgamma5[c,b],
conv@TBdeltaDirac[a_,b_]conv@TBgamma5[c_,a_]/;Not[NumberQ[a]]:>conv@TBgamma5[c,b],
conv@TBdeltaDirac[b_,a_]conv@TBgamma5[a_,c_]/;Not[NumberQ[a]]:>conv@TBgamma5[b,c],
conv@TBdeltaDirac[a_,b_]conv@TBgamma5[a_,c_]/;Not[NumberQ[a]]:>conv@TBgamma5[b,c]
};
Return[expr//.list1//.list2]
];


DiracTranspose::tooManyExternalIndices = "ForTransposition, only two open indices are supported. `1` as poen indices were supplied.";
DiracTranspose[expr_]:=Module[{exprNew,openIndices,dummpyIndex},

openIndices=GetOpenDiracIndices[expr];
If[Length[openIndices]!=2,Message[DiracTranspose::tooManyExternalIndices,openIndices];Abort[]];

exprNew=expr//.{openIndices[[1]]->dummpyIndex};
exprNew=exprNew//.{openIndices[[2]]->openIndices[[1]]};
exprNew=exprNew//.{dummpyIndex->openIndices[[2]]};

exprNew
];
DiracTranspose[expr_List]:=DiracTranspose/@expr;


(* ::Input::Initialization:: *)
PreTrace[expr_]:=Module[{exprExp},
Block[{Print},DisentangleLorentzStructures[False]];
exprExp=ExpandTerms[expr//integrateDeltas//InsertSU3GellManns];
Do[exprExp[[iDia,2,iFlavor,1]]=SU3GellMannTrace[ConvertInput[exprExp[[iDia,2,iFlavor,1]]]],{iDia,Length[exprExp]},{iFlavor,Length[exprExp[[iDia,2]]]}];
Return[ImplodeTerms[exprExp]//integrateDeltas//QuickSimplify];
];


SeparateScalarProductsFiniteT[expr_]:=Module[{},UseLorentzLinearity[expr]//.InsertOutputNaming@{TBsp[q_,p_]:>TBsps[q,p]+TBvec[q,0]TBvec[p,0],TBvec[p_,mu_/;mu=!=0]:>TBvecs[p,mu]+TBdeltaLorentz[mu,0]TBvec[p,0]}]

ExpandScalarProductsFiniteT[expr_]:=Module[{q,p},UseLorentzLinearity[expr]//.InsertOutputNaming@{TBsp[q_,p_]->TBsps[q,p]+TBvec[q,0]TBvec[p,0]}//.InsertOutputNaming@{TBsps[q_,p_]->q p cos[q,p], cos[p_,p_]->1}]

ExpandScalarProducts[expr_]:=Module[{q,p},UseLorentzLinearity[expr]//.InsertOutputNaming@{TBsp[q_,p_]->q p cos[q,p], cos[p_,p_]->1}]

SetAttributes[cos, Orderless];
Derivative[0,1][cos][p_,q_]=0;
Derivative[1,0][cos][p_,q_]=0;
cos[p_,p_]=1;

SimplifyAllMomenta[q_,expr_,qffac_:\[Pi] T]:=UseLorentzLinearity[expr]//.InsertOutputNaming@{
cos[p_,Symbol[ToString[q]<>"f"]]:>Symbol["cos"<>ToString[p]<>ToString[q]],
TBvec[q,0]:>Symbol[ToString[q]<>"0"],
TBvec[Symbol[ToString[q]<>"f"],0]:>(ClearAll[T];Symbol[ToString[q]<>"0"]+qffac)
}//.InsertOutputNaming@{
cos[p_,r_]:>Symbol["cos"<>ToString[p]<>ToString[r]],
TBvec[p_,0]:>Symbol[ToString[p]<>"0"],
Symbol[ToString[q]<>"f"]->q
}


ProjectToSymmetricPoint[expr_,q_Symbol,p_Symbol,momenta___Symbol]:=Module[{momentaList,nMomenta,rules,qf,
conv=InsertOutputNaming},
momentaList={momenta};
nMomenta=Length[momentaList];
qf=Symbol[ToString[q]<>"f"];
rules=Map[conv@TBsp[#[[1]],#[[2]]]->-(1/(nMomenta-1))conv@TBsp[p,p]&,Subsets[momentaList,{2}]]
\[Union]Map[conv@TBsp[#,#]->conv@TBsp[p,p]&,momentaList]
\[Union]Map[conv@TBsp[#,q]->Symbol["cos"~~ToString[#]~~"q"] p q&,momentaList]
\[Union]Map[conv@TBsp[#,qf]->Symbol["cos"~~ToString[#]~~"q"] p qf&,momentaList]
(*\[Union]{momentaList[[nMomenta]]->-Total[momentaList[[1;;nMomenta-1]]]}*);
(UseLorentzLinearity[expr]//.rules//UseLorentzLinearity)//.rules
]


ProjectToSymmetricPointFiniteT[expr_,q_Symbol,p_Symbol,momenta___Symbol]:=Module[{momentaList,nMomenta,rules,qf,
conv=InsertOutputNaming},
momentaList={momenta};
nMomenta=Length[momentaList];
qf=Symbol[ToString[q]<>"f"];
rules=Map[conv@TBsps[#[[1]],#[[2]]]->-(1/(nMomenta-1))conv@TBsps[p,p]&,Subsets[momentaList,{2}]]
\[Union]Map[conv@TBsps[#,#]->conv@TBsps[p,p]&,momentaList]
\[Union]Map[conv@TBsps[#,q]->Symbol["cos"~~ToString[#]~~"q"] p q&,momentaList]
\[Union]Map[conv@TBsps[#,qf]->Symbol["cos"~~ToString[#]~~"q"] p qf&,momentaList]
(*\[Union]{momentaList[[nMomenta]]->-Total[momentaList[[1;;nMomenta-1]]]}*);
(SeparateScalarProductsFiniteT[UseLorentzLinearity[expr]]//.rules//UseLorentzLinearity)//.rules
]


(* ::Input::Initialization:: *)
QuickSimplify[expr_] := Simplify[expr,TimeConstraint -> 0.1] // Quiet;


$StandardSimplify=Simplify;
SetStandardSimplify[sim_]:=Module[{},
$StandardSimplify=sim;
]
$StandardQuickSimplify=QuickSimplify;
SetStandardQuickSimplify[sim_]:=Module[{},
$StandardQuickSimplify=sim;
]


AdjustToNKernels[nKernels_Integer]:=Module[{},
If[nKernels!=0,
CloseKernels[];
LaunchKernels[nKernels];
DistributeDefinitions["TensorBases`Private`"];
DistributeDefinitions["FormTracer`"];
DistributeDefinitions[ExtendedFormTrace,InsertChargeConjRules]
];
]
RestoreKernels[]:=Module[{},
CloseKernels[];
LaunchKernels[];
DistributeDefinitions["TensorBases`Private`"];
DistributeDefinitions["FormTracer`"];
DistributeDefinitions[ExtendedFormTrace,InsertChargeConjRules];
]
DiFfRGMap[nKernels_Integer]:=Module[{},
If[nKernels<=1,
Return[ResourceFunction["DynamicMap"]],
Return[ResourceFunction["DynamicMap"][#1,#2,Parallel->nKernels]&]
];
];


(*End[]*)


Protect["DiFfRG`*"];


(*EndPackage[];*)
